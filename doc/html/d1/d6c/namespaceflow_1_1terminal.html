<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Flow: flow::terminal Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Flow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/de2/namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html">terminal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">flow::terminal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:de/d8a/namespaceflow_1_1terminal_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d8a/namespaceflow_1_1terminal_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afb46a36fe4c6693d7b05e3bd0fc05f4d"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:afb46a36fe4c6693d7b05e3bd0fc05f4d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb46a36fe4c6693d7b05e3bd0fc05f4d">all</a> (UnaryPredicate predicate)</td></tr>
<tr class="memdesc:afb46a36fe4c6693d7b05e3bd0fc05f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>false</code> value is found. If the stream is empty, this will return <code>true</code>.  <a href="#afb46a36fe4c6693d7b05e3bd0fc05f4d">More...</a><br /></td></tr>
<tr class="separator:afb46a36fe4c6693d7b05e3bd0fc05f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69ca58eca0161111d95306425586634"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ab69ca58eca0161111d95306425586634">all</a> ()</td></tr>
<tr class="memdesc:ab69ca58eca0161111d95306425586634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if all elements in the stream can be evaluated to <code>true</code>. This is an overload for streams with types convertible to <code>bool</code>. This operation is short circuited and will stop executing once any <code>false</code> value is found. If the stream is empty, this will return <code>true</code>.  <a href="#ab69ca58eca0161111d95306425586634">More...</a><br /></td></tr>
<tr class="separator:ab69ca58eca0161111d95306425586634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab756d99bb6fe64ace09d278028f0f539"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:ab756d99bb6fe64ace09d278028f0f539"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ab756d99bb6fe64ace09d278028f0f539">all</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:ab756d99bb6fe64ace09d278028f0f539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>false</code> value is found. If the stream is empty, this will return <code>true</code>.  <a href="#ab756d99bb6fe64ace09d278028f0f539">More...</a><br /></td></tr>
<tr class="separator:ab756d99bb6fe64ace09d278028f0f539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6844ddc5a40bb68764bc31f6070107"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aef6844ddc5a40bb68764bc31f6070107"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aef6844ddc5a40bb68764bc31f6070107">any</a> (UnaryPredicate predicate)</td></tr>
<tr class="memdesc:aef6844ddc5a40bb68764bc31f6070107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>false</code>.  <a href="#aef6844ddc5a40bb68764bc31f6070107">More...</a><br /></td></tr>
<tr class="separator:aef6844ddc5a40bb68764bc31f6070107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af592d8f034ddf176998928a0d3b86bd0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#af592d8f034ddf176998928a0d3b86bd0">any</a> ()</td></tr>
<tr class="memdesc:af592d8f034ddf176998928a0d3b86bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any element in the stream can be evaluated to <code>true</code>. This is an overload for streams with types convertible to <code>bool</code>. This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>false</code>.  <a href="#af592d8f034ddf176998928a0d3b86bd0">More...</a><br /></td></tr>
<tr class="separator:af592d8f034ddf176998928a0d3b86bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed588ae01b14be839486b94bb87f2ed8"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:aed588ae01b14be839486b94bb87f2ed8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aed588ae01b14be839486b94bb87f2ed8">any</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:aed588ae01b14be839486b94bb87f2ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>false</code>.  <a href="#aed588ae01b14be839486b94bb87f2ed8">More...</a><br /></td></tr>
<tr class="separator:aed588ae01b14be839486b94bb87f2ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3749b3050892e328fa6b38417806cf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename EqualPredicate  = std::equal_to&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aed3749b3050892e328fa6b38417806cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aed3749b3050892e328fa6b38417806cf">contains</a> (const T &amp;val, EqualPredicate equals=EqualPredicate())</td></tr>
<tr class="memdesc:aed3749b3050892e328fa6b38417806cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an element in the stream compares equal to <code>val</code> by the predicate given. By default, <code>operator==</code> is used for comparisons.  <a href="#aed3749b3050892e328fa6b38417806cf">More...</a><br /></td></tr>
<tr class="separator:aed3749b3050892e328fa6b38417806cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e701e11c61d1038e3b0581e2f32df0"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator &gt; </td></tr>
<tr class="memitem:aa2e701e11c61d1038e3b0581e2f32df0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aa2e701e11c61d1038e3b0581e2f32df0">copy</a> (OutputIterator result)</td></tr>
<tr class="memdesc:aa2e701e11c61d1038e3b0581e2f32df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the stream into the range beginning at <code>result</code>. An iterator to the end of the destination range is returned, pointing to the element after the last element copied.  <a href="#aa2e701e11c61d1038e3b0581e2f32df0">More...</a><br /></td></tr>
<tr class="separator:aa2e701e11c61d1038e3b0581e2f32df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dfcc0ff79f7c3d74ea2e80a3f9a65f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a52dfcc0ff79f7c3d74ea2e80a3f9a65f">count</a> ()</td></tr>
<tr class="memdesc:a52dfcc0ff79f7c3d74ea2e80a3f9a65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of elements in the stream. The count is returned as <code>std::size_t</code>.  <a href="#a52dfcc0ff79f7c3d74ea2e80a3f9a65f">More...</a><br /></td></tr>
<tr class="separator:a52dfcc0ff79f7c3d74ea2e80a3f9a65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0afd1d9f8846d76814248e4d6a164f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#acc0afd1d9f8846d76814248e4d6a164f">dump</a> (std::ostream &amp;out=std::cout, const std::string &amp;delimiter=&quot; &quot;)</td></tr>
<tr class="memdesc:acc0afd1d9f8846d76814248e4d6a164f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the stream elements to the <code>ostream</code> with the given delimiter between each element. The output stream is returned.  <a href="#acc0afd1d9f8846d76814248e4d6a164f">More...</a><br /></td></tr>
<tr class="separator:acc0afd1d9f8846d76814248e4d6a164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3d0ede6c9489aebb9ce1ed684c31a0"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a6b3d0ede6c9489aebb9ce1ed684c31a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a6b3d0ede6c9489aebb9ce1ed684c31a0">each</a> (UnaryFunction func)</td></tr>
<tr class="memdesc:a6b3d0ede6c9489aebb9ce1ed684c31a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a function for each element in the stream. The executed function is returned.  <a href="#a6b3d0ede6c9489aebb9ce1ed684c31a0">More...</a><br /></td></tr>
<tr class="separator:a6b3d0ede6c9489aebb9ce1ed684c31a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c7d99f1f196e5f9b55032c60097ece"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:a89c7d99f1f196e5f9b55032c60097ece"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a89c7d99f1f196e5f9b55032c60097ece">each</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:a89c7d99f1f196e5f9b55032c60097ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a function for each element in the stream. The executed function is returned.  <a href="#a89c7d99f1f196e5f9b55032c60097ece">More...</a><br /></td></tr>
<tr class="separator:a89c7d99f1f196e5f9b55032c60097ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2088cf5443957cdf935652bccc0b612"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae2088cf5443957cdf935652bccc0b612">first</a> ()</td></tr>
<tr class="memdesc:ae2088cf5443957cdf935652bccc0b612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element from the stream.  <a href="#ae2088cf5443957cdf935652bccc0b612">More...</a><br /></td></tr>
<tr class="separator:ae2088cf5443957cdf935652bccc0b612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76999f9b4b01425b09c070cc7154ec8"><td class="memTemplParams" colspan="2">template&lt;typename Accumulator , typename T &gt; </td></tr>
<tr class="memitem:ad76999f9b4b01425b09c070cc7154ec8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad76999f9b4b01425b09c070cc7154ec8">fold</a> (Accumulator accumulator, T &amp;&amp;init)</td></tr>
<tr class="memdesc:ad76999f9b4b01425b09c070cc7154ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the stream using the given accumulator. Applying this operation is the same as doing: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (T e : stream) { init = accumulator(init, e); }</div>
</div><!-- fragment -->  <a href="#ad76999f9b4b01425b09c070cc7154ec8">More...</a><br /></td></tr>
<tr class="separator:ad76999f9b4b01425b09c070cc7154ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf7db53b2573f8f651420cc508170f8"><td class="memTemplParams" colspan="2">template&lt;typename Accumulator &gt; </td></tr>
<tr class="memitem:aabf7db53b2573f8f651420cc508170f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aabf7db53b2573f8f651420cc508170f8">fold</a> (Accumulator accumulator)</td></tr>
<tr class="memdesc:aabf7db53b2573f8f651420cc508170f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the stream using the given accumulator. The first element of the stream is used for the inital folding value.  <a href="#aabf7db53b2573f8f651420cc508170f8">More...</a><br /></td></tr>
<tr class="separator:aabf7db53b2573f8f651420cc508170f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439e3f4a1be79bae0105092613415773"><td class="memTemplParams" colspan="2">template&lt;typename Accumulator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a439e3f4a1be79bae0105092613415773"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a439e3f4a1be79bae0105092613415773">fold_id</a> (Accumulator accumulator, UnaryFunction initializer)</td></tr>
<tr class="memdesc:a439e3f4a1be79bae0105092613415773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the stream using the given accumulator. The result of <code>initializer</code> applied to the first element of the stream is used for the inital folding value.  <a href="#a439e3f4a1be79bae0105092613415773">More...</a><br /></td></tr>
<tr class="separator:a439e3f4a1be79bae0105092613415773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71feb02eace70a6babe98181f1e7c579"><td class="memTemplParams" colspan="2">template&lt;typename Accumulator , typename UnaryFunction , typename T &gt; </td></tr>
<tr class="memitem:a71feb02eace70a6babe98181f1e7c579"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a71feb02eace70a6babe98181f1e7c579">fold_id</a> (Accumulator accumulator, UnaryFunction initializer, T &amp;&amp;init)</td></tr>
<tr class="memdesc:a71feb02eace70a6babe98181f1e7c579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the stream using the given accumulator. The result of <code>initializer</code> applied to <code>init</code> is used for the inital folding value.  <a href="#a71feb02eace70a6babe98181f1e7c579">More...</a><br /></td></tr>
<tr class="separator:a71feb02eace70a6babe98181f1e7c579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe0dda56d4f64d94e607e73b9187960"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a4fe0dda56d4f64d94e607e73b9187960">last</a> ()</td></tr>
<tr class="memdesc:a4fe0dda56d4f64d94e607e73b9187960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last element from the stream.  <a href="#a4fe0dda56d4f64d94e607e73b9187960">More...</a><br /></td></tr>
<tr class="separator:a4fe0dda56d4f64d94e607e73b9187960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa878b5ae4e25bf654161a5004ca025b3"><td class="memTemplParams" colspan="2">template&lt;typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:aa878b5ae4e25bf654161a5004ca025b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aa878b5ae4e25bf654161a5004ca025b3">max</a> (Compare compare=Compare())</td></tr>
<tr class="memdesc:aa878b5ae4e25bf654161a5004ca025b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum element from the stream according to the comparator given. By default <code>operator&lt;</code> is used for comparisons.  <a href="#aa878b5ae4e25bf654161a5004ca025b3">More...</a><br /></td></tr>
<tr class="separator:aa878b5ae4e25bf654161a5004ca025b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02d008becaf1d5d64d2ae358ae7306e"><td class="memTemplParams" colspan="2">template&lt;typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:ad02d008becaf1d5d64d2ae358ae7306e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad02d008becaf1d5d64d2ae358ae7306e">min</a> (Compare compare=Compare())</td></tr>
<tr class="memdesc:ad02d008becaf1d5d64d2ae358ae7306e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum element from the stream according to the comparator given. By default <code>operator&lt;</code> is used for comparisons.  <a href="#ad02d008becaf1d5d64d2ae358ae7306e">More...</a><br /></td></tr>
<tr class="separator:ad02d008becaf1d5d64d2ae358ae7306e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae944c0b98f14746eb980b9883e36a7e4"><td class="memTemplParams" colspan="2">template&lt;typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:ae944c0b98f14746eb980b9883e36a7e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae944c0b98f14746eb980b9883e36a7e4">minmax</a> (Compare compare=Compare())</td></tr>
<tr class="memdesc:ae944c0b98f14746eb980b9883e36a7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum and maximum elements as a pair from the stream according to the comparator given. The first element is the minimum and the second element is the maximum. By default <code>operator&lt;</code> is used for comparisons.  <a href="#ae944c0b98f14746eb980b9883e36a7e4">More...</a><br /></td></tr>
<tr class="separator:ae944c0b98f14746eb980b9883e36a7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6d1f983184706c6ec3a976c449ee6d"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a9e6d1f983184706c6ec3a976c449ee6d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e6d1f983184706c6ec3a976c449ee6d">none</a> (UnaryPredicate predicate)</td></tr>
<tr class="memdesc:a9e6d1f983184706c6ec3a976c449ee6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if none of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>true</code>.  <a href="#a9e6d1f983184706c6ec3a976c449ee6d">More...</a><br /></td></tr>
<tr class="separator:a9e6d1f983184706c6ec3a976c449ee6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c81d966a9a314a18cc091bbca744fc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae4c81d966a9a314a18cc091bbca744fc">none</a> ()</td></tr>
<tr class="memdesc:ae4c81d966a9a314a18cc091bbca744fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if none of the elements in the stream can be evaluated to <code>true</code>. This is an overload for streams with types convertible to <code>bool</code>. This operation is short circuited and will stop executing once any <code>true</code> value is found.  <a href="#ae4c81d966a9a314a18cc091bbca744fc">More...</a><br /></td></tr>
<tr class="separator:ae4c81d966a9a314a18cc091bbca744fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774947b90963349171b7964c524fb23a"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:a774947b90963349171b7964c524fb23a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a774947b90963349171b7964c524fb23a">none</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:a774947b90963349171b7964c524fb23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if none of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>true</code> value is found.  <a href="#a774947b90963349171b7964c524fb23a">More...</a><br /></td></tr>
<tr class="separator:a774947b90963349171b7964c524fb23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb644e7c13c0b2805f1e565763285da"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9eb644e7c13c0b2805f1e565763285da">nth</a> (std::size_t n)</td></tr>
<tr class="memdesc:a9eb644e7c13c0b2805f1e565763285da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth element from the stream. If the stream has fewer than <code>n</code> elements, this function will fail.  <a href="#a9eb644e7c13c0b2805f1e565763285da">More...</a><br /></td></tr>
<tr class="separator:a9eb644e7c13c0b2805f1e565763285da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc89d6fdbd682554a03d621d57dc0e19"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#adc89d6fdbd682554a03d621d57dc0e19">product</a> ()</td></tr>
<tr class="memdesc:adc89d6fdbd682554a03d621d57dc0e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of all the elements in the stream using <code>operator*</code>.  <a href="#adc89d6fdbd682554a03d621d57dc0e19">More...</a><br /></td></tr>
<tr class="separator:adc89d6fdbd682554a03d621d57dc0e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41837040615447514b15b28c578d829"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac41837040615447514b15b28c578d829"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ac41837040615447514b15b28c578d829">product</a> (T &amp;&amp;init)</td></tr>
<tr class="memdesc:ac41837040615447514b15b28c578d829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of all the elements in the stream using <code>operator*</code>, starting the product at <code>init</code>.  <a href="#ac41837040615447514b15b28c578d829">More...</a><br /></td></tr>
<tr class="separator:ac41837040615447514b15b28c578d829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d36eab187f4b501c07a00f39e4f2381"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381">sum</a> ()</td></tr>
<tr class="memdesc:a9d36eab187f4b501c07a00f39e4f2381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of all the elements in the stream using <code>operator+</code>.  <a href="#a9d36eab187f4b501c07a00f39e4f2381">More...</a><br /></td></tr>
<tr class="separator:a9d36eab187f4b501c07a00f39e4f2381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f36f6877d4af5794b93a8f1c0af92d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21f36f6877d4af5794b93a8f1c0af92d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a21f36f6877d4af5794b93a8f1c0af92d">sum</a> (T &amp;&amp;init)</td></tr>
<tr class="memdesc:a21f36f6877d4af5794b93a8f1c0af92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of all the elements in the stream using <code>operator+</code>, starting the sum at <code>init</code>.  <a href="#a21f36f6877d4af5794b93a8f1c0af92d">More...</a><br /></td></tr>
<tr class="separator:a21f36f6877d4af5794b93a8f1c0af92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dc13099ad26de78eccc63f7efad271"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; typename Alloc = std::allocator&gt; </td></tr>
<tr class="memitem:ae4dc13099ad26de78eccc63f7efad271"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae4dc13099ad26de78eccc63f7efad271">to_vector</a> ()</td></tr>
<tr class="memdesc:ae4dc13099ad26de78eccc63f7efad271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::vector&lt;T, Alloc&lt;T&gt;&gt;</code> in order.  <a href="#ae4dc13099ad26de78eccc63f7efad271">More...</a><br /></td></tr>
<tr class="separator:ae4dc13099ad26de78eccc63f7efad271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab64d8c770e599993b993036e25af893"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; typename Alloc = std::allocator&gt; </td></tr>
<tr class="memitem:aab64d8c770e599993b993036e25af893"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aab64d8c770e599993b993036e25af893">to_deque</a> ()</td></tr>
<tr class="memdesc:aab64d8c770e599993b993036e25af893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::deque&lt;T, Alloc&lt;T&gt;&gt;</code> in order.  <a href="#aab64d8c770e599993b993036e25af893">More...</a><br /></td></tr>
<tr class="separator:aab64d8c770e599993b993036e25af893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0220b84a0d18c61162cac48cd1bf7925"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; typename Alloc = std::allocator&gt; </td></tr>
<tr class="memitem:a0220b84a0d18c61162cac48cd1bf7925"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a0220b84a0d18c61162cac48cd1bf7925">to_forward_list</a> ()</td></tr>
<tr class="memdesc:a0220b84a0d18c61162cac48cd1bf7925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::forward_list&lt;T, Alloc&lt;T&gt;&gt;</code> in reverse order. Due to a lack of <code>push_back</code>, the list contains the stream elements in reverse order, as they are pushed to the front of the list instead.  <a href="#a0220b84a0d18c61162cac48cd1bf7925">More...</a><br /></td></tr>
<tr class="separator:a0220b84a0d18c61162cac48cd1bf7925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b7ba1e4981b0e2df9254b4831aa3b1"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; typename Alloc = std::allocator&gt; </td></tr>
<tr class="memitem:ac7b7ba1e4981b0e2df9254b4831aa3b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ac7b7ba1e4981b0e2df9254b4831aa3b1">to_list</a> ()</td></tr>
<tr class="memdesc:ac7b7ba1e4981b0e2df9254b4831aa3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::list&lt;T, Alloc&lt;T&gt;&gt;</code> in order.  <a href="#ac7b7ba1e4981b0e2df9254b4831aa3b1">More...</a><br /></td></tr>
<tr class="separator:ac7b7ba1e4981b0e2df9254b4831aa3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931b21e882fc9666304d7205886f4452"><td class="memTemplParams" colspan="2">template&lt;typename Compare  = std::less&lt;void&gt;, template&lt; typename &gt; typename Alloc = std::allocator&gt; </td></tr>
<tr class="memitem:a931b21e882fc9666304d7205886f4452"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a931b21e882fc9666304d7205886f4452">to_set</a> ()</td></tr>
<tr class="memdesc:a931b21e882fc9666304d7205886f4452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::set&lt;T, Compare, Alloc&lt;T&gt;&gt;</code>.  <a href="#a931b21e882fc9666304d7205886f4452">More...</a><br /></td></tr>
<tr class="separator:a931b21e882fc9666304d7205886f4452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3fbccb7a7a86e960f60b5b686519d9"><td class="memTemplParams" colspan="2">template&lt;typename Compare  = std::less&lt;void&gt;, template&lt; typename &gt; typename Alloc = std::allocator&gt; </td></tr>
<tr class="memitem:aad3fbccb7a7a86e960f60b5b686519d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aad3fbccb7a7a86e960f60b5b686519d9">to_multiset</a> ()</td></tr>
<tr class="memdesc:aad3fbccb7a7a86e960f60b5b686519d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::multiset&lt;T, Compare, Alloc&lt;T&gt;&gt;</code>.  <a href="#aad3fbccb7a7a86e960f60b5b686519d9">More...</a><br /></td></tr>
<tr class="separator:aad3fbccb7a7a86e960f60b5b686519d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738f8a51a1b5cdbee93236f39b5fca43"><td class="memTemplParams" colspan="2">template&lt;typename Hash  = detail::hash, typename UnaryPredicate  = std::equal_to&lt;void&gt;, template&lt; typename &gt; typename Alloc = std::allocator&gt; </td></tr>
<tr class="memitem:a738f8a51a1b5cdbee93236f39b5fca43"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a738f8a51a1b5cdbee93236f39b5fca43">to_unordered_set</a> ()</td></tr>
<tr class="memdesc:a738f8a51a1b5cdbee93236f39b5fca43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_set&lt;T, Hash, UnaryPredicate, Alloc&lt;T&gt;&gt;</code>.  <a href="#a738f8a51a1b5cdbee93236f39b5fca43">More...</a><br /></td></tr>
<tr class="separator:a738f8a51a1b5cdbee93236f39b5fca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d98aaaa327fd861f35ccaab3c81f075"><td class="memTemplParams" colspan="2">template&lt;typename Hash  = detail::hash, typename UnaryPredicate  = std::equal_to&lt;void&gt;, template&lt; typename &gt; typename Alloc = std::allocator&gt; </td></tr>
<tr class="memitem:a6d98aaaa327fd861f35ccaab3c81f075"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a6d98aaaa327fd861f35ccaab3c81f075">to_unordered_multiset</a> ()</td></tr>
<tr class="memdesc:a6d98aaaa327fd861f35ccaab3c81f075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_multiset&lt;T, Hash, UnaryPredicate, Alloc&lt;T&gt;&gt;</code>.  <a href="#a6d98aaaa327fd861f35ccaab3c81f075">More...</a><br /></td></tr>
<tr class="separator:a6d98aaaa327fd861f35ccaab3c81f075"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afb46a36fe4c6693d7b05e3bd0fc05f4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::all </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if all of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>false</code> value is found. If the stream is empty, this will return <code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if all stream element returns true for the given predicate.</dd></dl>

</div>
</div>
<a class="anchor" id="ab69ca58eca0161111d95306425586634"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if all elements in the stream can be evaluated to <code>true</code>. This is an overload for streams with types convertible to <code>bool</code>. This operation is short circuited and will stop executing once any <code>false</code> value is found. If the stream is empty, this will return <code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if all stream elements are true.</dd></dl>

</div>
</div>
<a class="anchor" id="ab756d99bb6fe64ace09d278028f0f539"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::all </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if all of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>false</code> value is found. If the stream is empty, this will return <code>true</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function to use as the predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if all stream element returns true for the given predicate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The const class member function to use as the predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if all stream element returns true for the given predicate.</dd></dl>

</div>
</div>
<a class="anchor" id="aef6844ddc5a40bb68764bc31f6070107"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::any </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if any of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>false</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if any stream element returns true for the given predicate.</dd></dl>

</div>
</div>
<a class="anchor" id="af592d8f034ddf176998928a0d3b86bd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if any element in the stream can be evaluated to <code>true</code>. This is an overload for streams with types convertible to <code>bool</code>. This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>false</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if any stream element is true.</dd></dl>

</div>
</div>
<a class="anchor" id="aed588ae01b14be839486b94bb87f2ed8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::any </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if any of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>false</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function to use as the predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if any stream element returns true for the given predicate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The const class member function to use as the predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if any stream element returns true for the given predicate.</dd></dl>

</div>
</div>
<a class="anchor" id="aed3749b3050892e328fa6b38417806cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename EqualPredicate  = std::equal_to&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::contains </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EqualPredicate&#160;</td>
          <td class="paramname"><em>equals</em> = <code>EqualPredicate()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an element in the stream compares equal to <code>val</code> by the predicate given. By default, <code>operator==</code> is used for comparisons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to search for in the stream.</td></tr>
    <tr><td class="paramname">equals</td><td>The equals predicate, by default <code>operator==</code> is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal{F} operation which returns <code>true</code> if the stream contains <code>val</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="aa2e701e11c61d1038e3b0581e2f32df0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::copy </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements in the stream into the range beginning at <code>result</code>. An iterator to the end of the destination range is returned, pointing to the element after the last element copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output iterator to the initial position in the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which copies the stream into the <code>result</code> range.</dd></dl>

</div>
</div>
<a class="anchor" id="a52dfcc0ff79f7c3d74ea2e80a3f9a65f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of elements in the stream. The count is returned as <code>std::size_t</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which counts the number of elements in the stream.</dd></dl>

</div>
</div>
<a class="anchor" id="acc0afd1d9f8846d76814248e4d6a164f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the stream elements to the <code>ostream</code> with the given delimiter between each element. The output stream is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream to print to.</td></tr>
    <tr><td class="paramname">delimiter</td><td>The delimiter to add after each element, by default a single space is added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which print the stream elements to the output stream given.</dd></dl>

</div>
</div>
<a class="anchor" id="a6b3d0ede6c9489aebb9ce1ed684c31a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::each </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a function for each element in the stream. The executed function is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to apply to each element of the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation that executes a function for each stream element.</dd></dl>

</div>
</div>
<a class="anchor" id="a89c7d99f1f196e5f9b55032c60097ece"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::each </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a function for each element in the stream. The executed function is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function to use as the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation that executes a function for each stream element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The const class member function to use as the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation that executes a function for each stream element.</dd></dl>

</div>
</div>
<a class="anchor" id="ae2088cf5443957cdf935652bccc0b612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first element from the stream. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which gives the first element from the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the stream is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad76999f9b4b01425b09c070cc7154ec8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accumulator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::fold </td>
          <td>(</td>
          <td class="paramtype">Accumulator&#160;</td>
          <td class="paramname"><em>accumulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Folds the stream using the given accumulator. Applying this operation is the same as doing: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (T e : stream) { init = accumulator(init, e); }</div>
</div><!-- fragment --> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accumulator</td><td>The accumulator, the function through which the stream is folded.</td></tr>
    <tr><td class="paramname">init</td><td>The initial value to start the folding operation at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which folds the stream.</dd></dl>

</div>
</div>
<a class="anchor" id="aabf7db53b2573f8f651420cc508170f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accumulator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::fold </td>
          <td>(</td>
          <td class="paramtype">Accumulator&#160;</td>
          <td class="paramname"><em>accumulator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Folds the stream using the given accumulator. The first element of the stream is used for the inital folding value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accumulator</td><td>The accumulator, the function through which the stream is folded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which folds the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the stream is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a439e3f4a1be79bae0105092613415773"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accumulator , typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::fold_id </td>
          <td>(</td>
          <td class="paramtype">Accumulator&#160;</td>
          <td class="paramname"><em>accumulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>initializer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Folds the stream using the given accumulator. The result of <code>initializer</code> applied to the first element of the stream is used for the inital folding value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accumulator</td><td>The accumulator, the function through which the stream is folded.</td></tr>
    <tr><td class="paramname">initializer</td><td>The initializer function to apply to the first element in the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which folds the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the stream is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71feb02eace70a6babe98181f1e7c579"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accumulator , typename UnaryFunction , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::fold_id </td>
          <td>(</td>
          <td class="paramtype">Accumulator&#160;</td>
          <td class="paramname"><em>accumulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>initializer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Folds the stream using the given accumulator. The result of <code>initializer</code> applied to <code>init</code> is used for the inital folding value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accumulator</td><td>The accumulator, the function through which the stream is folded.</td></tr>
    <tr><td class="paramname">initializer</td><td>The initializer function to apply to the first element in the stream.</td></tr>
    <tr><td class="paramname">init</td><td>The initial value to start the folding operation at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which folds the stream.</dd></dl>

</div>
</div>
<a class="anchor" id="a4fe0dda56d4f64d94e607e73b9187960"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last element from the stream. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which gives the last element from the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the stream is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa878b5ae4e25bf654161a5004ca025b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::max </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum element from the stream according to the comparator given. By default <code>operator&lt;</code> is used for comparisons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The compare function, by default <code>std::less{T}</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Terminal operation which gives the maximum element from the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the stream is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad02d008becaf1d5d64d2ae358ae7306e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::min </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum element from the stream according to the comparator given. By default <code>operator&lt;</code> is used for comparisons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The compare function, by default <code>std::less{T}</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Terminal operation which gives the minimum element from the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the stream is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae944c0b98f14746eb980b9883e36a7e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::minmax </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum and maximum elements as a pair from the stream according to the comparator given. The first element is the minimum and the second element is the maximum. By default <code>operator&lt;</code> is used for comparisons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The compare function, by default <code>std::less{T}</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Terminal{F} operation which gives the min and max elements from the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the stream is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e6d1f983184706c6ec3a976c449ee6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::none </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if none of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if all stream element returns true for the given predicate.</dd></dl>

</div>
</div>
<a class="anchor" id="ae4c81d966a9a314a18cc091bbca744fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if none of the elements in the stream can be evaluated to <code>true</code>. This is an overload for streams with types convertible to <code>bool</code>. This operation is short circuited and will stop executing once any <code>true</code> value is found. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if all stream elements are true.</dd></dl>

</div>
</div>
<a class="anchor" id="a774947b90963349171b7964c524fb23a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::none </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if none of the elements in the stream return <code>true</code> for the predicate given. This operation is short circuited and will stop executing once any <code>true</code> value is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function to use as the predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if all stream element returns true for the given predicate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The const class member function to use as the predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which returns true if all stream element returns true for the given predicate.</dd></dl>

</div>
</div>
<a class="anchor" id="a9eb644e7c13c0b2805f1e565763285da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::nth </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nth element from the stream. If the stream has fewer than <code>n</code> elements, this function will fail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal{F} operation which gives the nth element from the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the stream has fewer than <code>n</code> elements.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc89d6fdbd682554a03d621d57dc0e19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::product </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the product of all the elements in the stream using <code>operator*</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which multiplies the elements in the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the stream is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac41837040615447514b15b28c578d829"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::product </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the product of all the elements in the stream using <code>operator*</code>, starting the product at <code>init</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The initial value to start the product at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which multiplies the elements in the stream.</dd></dl>

</div>
</div>
<a class="anchor" id="a9d36eab187f4b501c07a00f39e4f2381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of all the elements in the stream using <code>operator+</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which sums the elements in the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the stream is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21f36f6877d4af5794b93a8f1c0af92d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::sum </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of all the elements in the stream using <code>operator+</code>, starting the sum at <code>init</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The initial value to start the sum at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which sums the elements in the stream.</dd></dl>

</div>
</div>
<a class="anchor" id="aab64d8c770e599993b993036e25af893"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Alloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_deque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::deque&lt;T, Alloc&lt;T&gt;&gt;</code> in order. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which copies the stream into a <code>std::deque</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a0220b84a0d18c61162cac48cd1bf7925"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Alloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_forward_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::forward_list&lt;T, Alloc&lt;T&gt;&gt;</code> in reverse order. Due to a lack of <code>push_back</code>, the list contains the stream elements in reverse order, as they are pushed to the front of the list instead. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which copies the stream into a <code>std::forward_list</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="ac7b7ba1e4981b0e2df9254b4831aa3b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Alloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::list&lt;T, Alloc&lt;T&gt;&gt;</code> in order. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which copies the stream into a <code>std::list</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="aad3fbccb7a7a86e960f60b5b686519d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare  = std::less&lt;void&gt;, template&lt; typename &gt; typename Alloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_multiset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::multiset&lt;T, Compare, Alloc&lt;T&gt;&gt;</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which copies the stream into a <code>std::multiset</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a931b21e882fc9666304d7205886f4452"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare  = std::less&lt;void&gt;, template&lt; typename &gt; typename Alloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::set&lt;T, Compare, Alloc&lt;T&gt;&gt;</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which copies the stream into a <code>std::set</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a6d98aaaa327fd861f35ccaab3c81f075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash  = detail::hash, typename UnaryPredicate  = std::equal_to&lt;void&gt;, template&lt; typename &gt; typename Alloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_multiset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_multiset&lt;T, Hash, UnaryPredicate, Alloc&lt;T&gt;&gt;</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which copies the stream into a <code>std::unordered_multiset</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a738f8a51a1b5cdbee93236f39b5fca43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash  = detail::hash, typename UnaryPredicate  = std::equal_to&lt;void&gt;, template&lt; typename &gt; typename Alloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_set&lt;T, Hash, UnaryPredicate, Alloc&lt;T&gt;&gt;</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which copies the stream into a <code>std::unordered_set</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="ae4dc13099ad26de78eccc63f7efad271"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Alloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::vector&lt;T, Alloc&lt;T&gt;&gt;</code> in order. </p>
<dl class="section return"><dt>Returns</dt><dd>The Terminal operation which copies the stream into a <code>std::vector</code>.</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 11 2015 17:59:56 for Flow by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
