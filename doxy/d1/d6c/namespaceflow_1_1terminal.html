<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Flow: flow::terminal Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Flow
   </div>
   <div id="projectbrief">Lazy Evaluated Stream Processing in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/de2/namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html">terminal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">flow::terminal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Terminal operations, all of which are also aliased in the flow namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afb46a36fe4c6693d7b05e3bd0fc05f4d"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:afb46a36fe4c6693d7b05e3bd0fc05f4d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb46a36fe4c6693d7b05e3bd0fc05f4d">all</a> (UnaryPredicate predicate)</td></tr>
<tr class="memdesc:afb46a36fe4c6693d7b05e3bd0fc05f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if all of the elements in the stream return <code>true</code> for <em>predicate</em> .  <a href="#afb46a36fe4c6693d7b05e3bd0fc05f4d">More...</a><br /></td></tr>
<tr class="separator:afb46a36fe4c6693d7b05e3bd0fc05f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69ca58eca0161111d95306425586634"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ab69ca58eca0161111d95306425586634">all</a> ()</td></tr>
<tr class="memdesc:ab69ca58eca0161111d95306425586634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if all elements in the stream can be evaluated to <code>true</code>.  <a href="#ab69ca58eca0161111d95306425586634">More...</a><br /></td></tr>
<tr class="separator:ab69ca58eca0161111d95306425586634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab756d99bb6fe64ace09d278028f0f539"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:ab756d99bb6fe64ace09d278028f0f539"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ab756d99bb6fe64ace09d278028f0f539">all</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:ab756d99bb6fe64ace09d278028f0f539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if all of the elements in the stream return <code>true</code> for <em>member</em> .  <a href="#ab756d99bb6fe64ace09d278028f0f539">More...</a><br /></td></tr>
<tr class="separator:ab756d99bb6fe64ace09d278028f0f539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6844ddc5a40bb68764bc31f6070107"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aef6844ddc5a40bb68764bc31f6070107"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aef6844ddc5a40bb68764bc31f6070107">any</a> (UnaryPredicate predicate)</td></tr>
<tr class="memdesc:aef6844ddc5a40bb68764bc31f6070107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any of the elements in the stream return <code>true</code> for <em>predicate</em> .  <a href="#aef6844ddc5a40bb68764bc31f6070107">More...</a><br /></td></tr>
<tr class="separator:aef6844ddc5a40bb68764bc31f6070107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af592d8f034ddf176998928a0d3b86bd0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#af592d8f034ddf176998928a0d3b86bd0">any</a> ()</td></tr>
<tr class="memdesc:af592d8f034ddf176998928a0d3b86bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any element in the stream can be evaluated to <code>true</code>.  <a href="#af592d8f034ddf176998928a0d3b86bd0">More...</a><br /></td></tr>
<tr class="separator:af592d8f034ddf176998928a0d3b86bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed588ae01b14be839486b94bb87f2ed8"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:aed588ae01b14be839486b94bb87f2ed8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aed588ae01b14be839486b94bb87f2ed8">any</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:aed588ae01b14be839486b94bb87f2ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any of the elements in the stream return <code>true</code> for <em>member</em> .  <a href="#aed588ae01b14be839486b94bb87f2ed8">More...</a><br /></td></tr>
<tr class="separator:aed588ae01b14be839486b94bb87f2ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc94fb24c31b8f7e46d8603a6997589b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc94fb24c31b8f7e46d8603a6997589b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afc94fb24c31b8f7e46d8603a6997589b">contains</a> (T &amp;&amp;val)</td></tr>
<tr class="memdesc:afc94fb24c31b8f7e46d8603a6997589b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an element in the stream compares equal to <code>val</code> by <code>operator==</code>.  <a href="#afc94fb24c31b8f7e46d8603a6997589b">More...</a><br /></td></tr>
<tr class="separator:afc94fb24c31b8f7e46d8603a6997589b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e701e11c61d1038e3b0581e2f32df0"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator &gt; </td></tr>
<tr class="memitem:aa2e701e11c61d1038e3b0581e2f32df0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aa2e701e11c61d1038e3b0581e2f32df0">copy</a> (OutputIterator result)</td></tr>
<tr class="memdesc:aa2e701e11c61d1038e3b0581e2f32df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the stream into the range beginning at <code>result</code>.  <a href="#aa2e701e11c61d1038e3b0581e2f32df0">More...</a><br /></td></tr>
<tr class="separator:aa2e701e11c61d1038e3b0581e2f32df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dfcc0ff79f7c3d74ea2e80a3f9a65f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a52dfcc0ff79f7c3d74ea2e80a3f9a65f">count</a> ()</td></tr>
<tr class="memdesc:a52dfcc0ff79f7c3d74ea2e80a3f9a65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the stream as <code>std::size_t</code>.  <a href="#a52dfcc0ff79f7c3d74ea2e80a3f9a65f">More...</a><br /></td></tr>
<tr class="separator:a52dfcc0ff79f7c3d74ea2e80a3f9a65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6459123c95b8fd67a2771d63addf036"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6459123c95b8fd67a2771d63addf036"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#af6459123c95b8fd67a2771d63addf036">count</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:af6459123c95b8fd67a2771d63addf036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the occurrences of <em>value</em>  in the stream as <code>std::size_t</code>.  <a href="#af6459123c95b8fd67a2771d63addf036">More...</a><br /></td></tr>
<tr class="separator:af6459123c95b8fd67a2771d63addf036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6b4fef03bc255768e41ab77d3b36ef"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a9e6b4fef03bc255768e41ab77d3b36ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e6b4fef03bc255768e41ab77d3b36ef">count_if</a> (UnaryPredicate predicate)</td></tr>
<tr class="memdesc:a9e6b4fef03bc255768e41ab77d3b36ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the stream that return <code>true</code> for <em>predicate</em>  as <code>std::size_t</code>.  <a href="#a9e6b4fef03bc255768e41ab77d3b36ef">More...</a><br /></td></tr>
<tr class="separator:a9e6b4fef03bc255768e41ab77d3b36ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0afd1d9f8846d76814248e4d6a164f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#acc0afd1d9f8846d76814248e4d6a164f">dump</a> (std::ostream &amp;out=std::cout, const std::string &amp;delimiter=&quot; &quot;)</td></tr>
<tr class="memdesc:acc0afd1d9f8846d76814248e4d6a164f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the stream elements to <em>out</em>  with <em>delimiter</em>  printed after each element.  <a href="#acc0afd1d9f8846d76814248e4d6a164f">More...</a><br /></td></tr>
<tr class="separator:acc0afd1d9f8846d76814248e4d6a164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3d0ede6c9489aebb9ce1ed684c31a0"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a6b3d0ede6c9489aebb9ce1ed684c31a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a6b3d0ede6c9489aebb9ce1ed684c31a0">each</a> (UnaryFunction func)</td></tr>
<tr class="memdesc:a6b3d0ede6c9489aebb9ce1ed684c31a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a function for each element in the stream.  <a href="#a6b3d0ede6c9489aebb9ce1ed684c31a0">More...</a><br /></td></tr>
<tr class="separator:a6b3d0ede6c9489aebb9ce1ed684c31a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c7d99f1f196e5f9b55032c60097ece"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:a89c7d99f1f196e5f9b55032c60097ece"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a89c7d99f1f196e5f9b55032c60097ece">each</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:a89c7d99f1f196e5f9b55032c60097ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the member function for each element in the stream.  <a href="#a89c7d99f1f196e5f9b55032c60097ece">More...</a><br /></td></tr>
<tr class="separator:a89c7d99f1f196e5f9b55032c60097ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1e1a50b753d81652abaa28a9292eb4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afc1e1a50b753d81652abaa28a9292eb4">execute</a> ()</td></tr>
<tr class="memdesc:afc1e1a50b753d81652abaa28a9292eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the stream to be evaluated entirely.  <a href="#afc1e1a50b753d81652abaa28a9292eb4">More...</a><br /></td></tr>
<tr class="separator:afc1e1a50b753d81652abaa28a9292eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2088cf5443957cdf935652bccc0b612"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae2088cf5443957cdf935652bccc0b612">first</a> ()</td></tr>
<tr class="memdesc:ae2088cf5443957cdf935652bccc0b612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element from the stream as an optional.  <a href="#ae2088cf5443957cdf935652bccc0b612">More...</a><br /></td></tr>
<tr class="separator:ae2088cf5443957cdf935652bccc0b612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76999f9b4b01425b09c070cc7154ec8"><td class="memTemplParams" colspan="2">template&lt;typename Accumulator , typename T &gt; </td></tr>
<tr class="memitem:ad76999f9b4b01425b09c070cc7154ec8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad76999f9b4b01425b09c070cc7154ec8">fold</a> (Accumulator accumulator, T &amp;&amp;init)</td></tr>
<tr class="memdesc:ad76999f9b4b01425b09c070cc7154ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the stream using the <em>accumulator</em> .  <a href="#ad76999f9b4b01425b09c070cc7154ec8">More...</a><br /></td></tr>
<tr class="separator:ad76999f9b4b01425b09c070cc7154ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf7db53b2573f8f651420cc508170f8"><td class="memTemplParams" colspan="2">template&lt;typename Accumulator &gt; </td></tr>
<tr class="memitem:aabf7db53b2573f8f651420cc508170f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aabf7db53b2573f8f651420cc508170f8">fold</a> (Accumulator accumulator)</td></tr>
<tr class="memdesc:aabf7db53b2573f8f651420cc508170f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the stream using <em>accumulator</em> , returning the value as an optional.  <a href="#aabf7db53b2573f8f651420cc508170f8">More...</a><br /></td></tr>
<tr class="separator:aabf7db53b2573f8f651420cc508170f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71feb02eace70a6babe98181f1e7c579"><td class="memTemplParams" colspan="2">template&lt;typename Accumulator , typename UnaryFunction , typename T &gt; </td></tr>
<tr class="memitem:a71feb02eace70a6babe98181f1e7c579"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a71feb02eace70a6babe98181f1e7c579">fold_id</a> (Accumulator accumulator, UnaryFunction initializer, T &amp;&amp;init)</td></tr>
<tr class="memdesc:a71feb02eace70a6babe98181f1e7c579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the stream using <em>accumulator</em> .  <a href="#a71feb02eace70a6babe98181f1e7c579">More...</a><br /></td></tr>
<tr class="separator:a71feb02eace70a6babe98181f1e7c579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439e3f4a1be79bae0105092613415773"><td class="memTemplParams" colspan="2">template&lt;typename Accumulator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a439e3f4a1be79bae0105092613415773"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a439e3f4a1be79bae0105092613415773">fold_id</a> (Accumulator accumulator, UnaryFunction initializer)</td></tr>
<tr class="memdesc:a439e3f4a1be79bae0105092613415773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the stream using <em>accumulator</em> , returning the value as an optional.  <a href="#a439e3f4a1be79bae0105092613415773">More...</a><br /></td></tr>
<tr class="separator:a439e3f4a1be79bae0105092613415773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338ea201d1ada38a3c2afec6944fbc42"><td class="memTemplParams" colspan="2">template&lt;typename Source , typename T , typename ProductFunction  = std::multiplies&lt;void&gt;, typename SumFunction  = std::plus&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a338ea201d1ada38a3c2afec6944fbc42"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a338ea201d1ada38a3c2afec6944fbc42">inner_product</a> (<a class="el" href="../../d9/dcd/classflow_1_1_stream.html">Stream</a>&lt; Source &gt; &amp;&amp;right, T &amp;&amp;value, ProductFunction times=ProductFunction(), SumFunction plus=SumFunction())</td></tr>
<tr class="memdesc:a338ea201d1ada38a3c2afec6944fbc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inner product (also known as dot product) of the two streams.  <a href="#a338ea201d1ada38a3c2afec6944fbc42">More...</a><br /></td></tr>
<tr class="separator:a338ea201d1ada38a3c2afec6944fbc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa80485667da9ab8a6cfdf4651a87150"><td class="memTemplParams" colspan="2">template&lt;typename Itr , typename T , typename ProductFunction  = std::multiplies&lt;void&gt;, typename SumFunction  = std::plus&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aaa80485667da9ab8a6cfdf4651a87150"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aaa80485667da9ab8a6cfdf4651a87150">inner_product</a> (Itr begin, Itr end, T &amp;&amp;value, ProductFunction times=ProductFunction(), SumFunction plus=SumFunction())</td></tr>
<tr class="memdesc:aaa80485667da9ab8a6cfdf4651a87150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inner product (also known as dot product) of the stream and iterator range, this is the same as <code>inner_product(from(begin, end), value, times, plus)</code>.  <a href="#aaa80485667da9ab8a6cfdf4651a87150">More...</a><br /></td></tr>
<tr class="separator:aaa80485667da9ab8a6cfdf4651a87150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f4741c21faf2386a61774ba5eee6a9"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T , typename ProductFunction  = std::multiplies&lt;void&gt;, typename SumFunction  = std::plus&lt;T&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a21f4741c21faf2386a61774ba5eee6a9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a21f4741c21faf2386a61774ba5eee6a9">inner_product</a> (Container &amp;container, T &amp;&amp;value, ProductFunction times=ProductFunction(), SumFunction plus=SumFunction())</td></tr>
<tr class="memdesc:a21f4741c21faf2386a61774ba5eee6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inner product (also known as dot product) of the stream and <em>container</em> , this is the same as <code>inner_product(from(container), value, times, plus)</code>.  <a href="#a21f4741c21faf2386a61774ba5eee6a9">More...</a><br /></td></tr>
<tr class="separator:a21f4741c21faf2386a61774ba5eee6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1febd32cb8ca10885dcffff7861b26"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename ProductFunction  = std::multiplies&lt;void&gt;, typename SumFunction  = std::plus&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a3a1febd32cb8ca10885dcffff7861b26"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a3a1febd32cb8ca10885dcffff7861b26">inner_product</a> (std::initializer_list&lt; T &gt; list, U &amp;&amp;value, ProductFunction times=ProductFunction(), SumFunction plus=SumFunction())</td></tr>
<tr class="memdesc:a3a1febd32cb8ca10885dcffff7861b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inner product (also known as dot product) of the stream and <em>list</em> , this is the same as <code>inner_product(from(list), value, times, plus)</code>.  <a href="#a3a1febd32cb8ca10885dcffff7861b26">More...</a><br /></td></tr>
<tr class="separator:a3a1febd32cb8ca10885dcffff7861b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe0dda56d4f64d94e607e73b9187960"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a4fe0dda56d4f64d94e607e73b9187960">last</a> ()</td></tr>
<tr class="memdesc:a4fe0dda56d4f64d94e607e73b9187960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last element from the stream as an optional.  <a href="#a4fe0dda56d4f64d94e607e73b9187960">More...</a><br /></td></tr>
<tr class="separator:a4fe0dda56d4f64d94e607e73b9187960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa878b5ae4e25bf654161a5004ca025b3"><td class="memTemplParams" colspan="2">template&lt;typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:aa878b5ae4e25bf654161a5004ca025b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aa878b5ae4e25bf654161a5004ca025b3">max</a> (Compare compare=Compare())</td></tr>
<tr class="memdesc:aa878b5ae4e25bf654161a5004ca025b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum element from the stream as an optional according to <em>compare</em> , <code>operator&lt;</code> by default.  <a href="#aa878b5ae4e25bf654161a5004ca025b3">More...</a><br /></td></tr>
<tr class="separator:aa878b5ae4e25bf654161a5004ca025b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02d008becaf1d5d64d2ae358ae7306e"><td class="memTemplParams" colspan="2">template&lt;typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:ad02d008becaf1d5d64d2ae358ae7306e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad02d008becaf1d5d64d2ae358ae7306e">min</a> (Compare compare=Compare())</td></tr>
<tr class="memdesc:ad02d008becaf1d5d64d2ae358ae7306e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum element from the stream as an optional according to <em>compare</em> , <code>operator&lt;</code> by default.  <a href="#ad02d008becaf1d5d64d2ae358ae7306e">More...</a><br /></td></tr>
<tr class="separator:ad02d008becaf1d5d64d2ae358ae7306e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae944c0b98f14746eb980b9883e36a7e4"><td class="memTemplParams" colspan="2">template&lt;typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:ae944c0b98f14746eb980b9883e36a7e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae944c0b98f14746eb980b9883e36a7e4">minmax</a> (Compare compare=Compare())</td></tr>
<tr class="memdesc:ae944c0b98f14746eb980b9883e36a7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum and maximum elements as a optional pair from the stream according to <em>compare</em> , <code>operator&lt;</code> by default.  <a href="#ae944c0b98f14746eb980b9883e36a7e4">More...</a><br /></td></tr>
<tr class="separator:ae944c0b98f14746eb980b9883e36a7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6d1f983184706c6ec3a976c449ee6d"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a9e6d1f983184706c6ec3a976c449ee6d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e6d1f983184706c6ec3a976c449ee6d">none</a> (UnaryPredicate predicate)</td></tr>
<tr class="memdesc:a9e6d1f983184706c6ec3a976c449ee6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if none of the elements in the stream return <code>true</code> for <em>predicate</em> .  <a href="#a9e6d1f983184706c6ec3a976c449ee6d">More...</a><br /></td></tr>
<tr class="separator:a9e6d1f983184706c6ec3a976c449ee6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c81d966a9a314a18cc091bbca744fc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae4c81d966a9a314a18cc091bbca744fc">none</a> ()</td></tr>
<tr class="memdesc:ae4c81d966a9a314a18cc091bbca744fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if none of the elements in the stream can be evaluated to <code>true</code>.  <a href="#ae4c81d966a9a314a18cc091bbca744fc">More...</a><br /></td></tr>
<tr class="separator:ae4c81d966a9a314a18cc091bbca744fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774947b90963349171b7964c524fb23a"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:a774947b90963349171b7964c524fb23a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a774947b90963349171b7964c524fb23a">none</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:a774947b90963349171b7964c524fb23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if none of the elements in the stream return <code>true</code> for <em>member</em> .  <a href="#a774947b90963349171b7964c524fb23a">More...</a><br /></td></tr>
<tr class="separator:a774947b90963349171b7964c524fb23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb644e7c13c0b2805f1e565763285da"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9eb644e7c13c0b2805f1e565763285da">nth</a> (std::size_t n)</td></tr>
<tr class="memdesc:a9eb644e7c13c0b2805f1e565763285da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth element from the stream as an optional.  <a href="#a9eb644e7c13c0b2805f1e565763285da">More...</a><br /></td></tr>
<tr class="separator:a9eb644e7c13c0b2805f1e565763285da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc89d6fdbd682554a03d621d57dc0e19"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#adc89d6fdbd682554a03d621d57dc0e19">product</a> ()</td></tr>
<tr class="memdesc:adc89d6fdbd682554a03d621d57dc0e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all the elements in the stream using <code>operator*</code> as an optional.  <a href="#adc89d6fdbd682554a03d621d57dc0e19">More...</a><br /></td></tr>
<tr class="separator:adc89d6fdbd682554a03d621d57dc0e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41837040615447514b15b28c578d829"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac41837040615447514b15b28c578d829"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ac41837040615447514b15b28c578d829">product</a> (T &amp;&amp;init)</td></tr>
<tr class="memdesc:ac41837040615447514b15b28c578d829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all the elements in the stream using <code>operator*</code>, starting the product at <em>init</em> .  <a href="#ac41837040615447514b15b28c578d829">More...</a><br /></td></tr>
<tr class="separator:ac41837040615447514b15b28c578d829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb323e26fb0ea79bd18bba9edfd8ec86"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb323e26fb0ea79bd18bba9edfd8ec86">reservoir</a> (std::size_t n, std::size_t execution_limit)</td></tr>
<tr class="memdesc:afb323e26fb0ea79bd18bba9edfd8ec86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random sample from the potentially infinite stream in a <code>std::vector</code>.  <a href="#afb323e26fb0ea79bd18bba9edfd8ec86">More...</a><br /></td></tr>
<tr class="separator:afb323e26fb0ea79bd18bba9edfd8ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44a519f0dc4368647050c9b1857dd40"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aa44a519f0dc4368647050c9b1857dd40">reservoir</a> (std::size_t n)</td></tr>
<tr class="memdesc:aa44a519f0dc4368647050c9b1857dd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random sample from the potentially infinite stream in a <code>std::vector</code>.  <a href="#aa44a519f0dc4368647050c9b1857dd40">More...</a><br /></td></tr>
<tr class="separator:aa44a519f0dc4368647050c9b1857dd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae875fa53b5a07351a74291d1814e5eb3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae875fa53b5a07351a74291d1814e5eb3">sample</a> (std::size_t n)</td></tr>
<tr class="memdesc:ae875fa53b5a07351a74291d1814e5eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random sample from the finite stream in a <code>std::vector</code>.  <a href="#ae875fa53b5a07351a74291d1814e5eb3">More...</a><br /></td></tr>
<tr class="separator:ae875fa53b5a07351a74291d1814e5eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43d66a22a81d6c1499d6240f74f31e4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ac43d66a22a81d6c1499d6240f74f31e4">sample_heap</a> (std::size_t n)</td></tr>
<tr class="memdesc:ac43d66a22a81d6c1499d6240f74f31e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random sample from the finite stream in a <code>std::vector</code>.  <a href="#ac43d66a22a81d6c1499d6240f74f31e4">More...</a><br /></td></tr>
<tr class="separator:ac43d66a22a81d6c1499d6240f74f31e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cad9fb8be0557995c03f1eb6045c7be"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a3cad9fb8be0557995c03f1eb6045c7be">sample_shuffle</a> (std::size_t n)</td></tr>
<tr class="memdesc:a3cad9fb8be0557995c03f1eb6045c7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random sample from the finite stream in a <code>std::vector</code>.  <a href="#a3cad9fb8be0557995c03f1eb6045c7be">More...</a><br /></td></tr>
<tr class="separator:a3cad9fb8be0557995c03f1eb6045c7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900a16920892b0445f890cad56458c9a"><td class="memTemplParams" colspan="2">template&lt;typename ResultType  = double, bool MinMax = false, bool MedianMode = false&gt; </td></tr>
<tr class="memitem:a900a16920892b0445f890cad56458c9a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a900a16920892b0445f890cad56458c9a">stats</a> ()</td></tr>
<tr class="memdesc:a900a16920892b0445f890cad56458c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="../../dd/d45/classflow_1_1_stats.html" title="Class to wrap all the statistics returned by stats(). ">Stats</a> object which contains several statistics of the stream values.  <a href="#a900a16920892b0445f890cad56458c9a">More...</a><br /></td></tr>
<tr class="separator:a900a16920892b0445f890cad56458c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d36eab187f4b501c07a00f39e4f2381"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381">sum</a> ()</td></tr>
<tr class="memdesc:a9d36eab187f4b501c07a00f39e4f2381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all the elements in the stream using <code>operator+</code> as an optional.  <a href="#a9d36eab187f4b501c07a00f39e4f2381">More...</a><br /></td></tr>
<tr class="separator:a9d36eab187f4b501c07a00f39e4f2381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f36f6877d4af5794b93a8f1c0af92d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21f36f6877d4af5794b93a8f1c0af92d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a21f36f6877d4af5794b93a8f1c0af92d">sum</a> (T &amp;&amp;init)</td></tr>
<tr class="memdesc:a21f36f6877d4af5794b93a8f1c0af92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of all the elements in the stream using <code>operator+</code>, starting the sum at <em>init</em> .  <a href="#a21f36f6877d4af5794b93a8f1c0af92d">More...</a><br /></td></tr>
<tr class="separator:a21f36f6877d4af5794b93a8f1c0af92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f69e7aa0b702ed9ed611b1dc8924f53"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9f69e7aa0b702ed9ed611b1dc8924f53">to_deque</a> ()</td></tr>
<tr class="memdesc:a9f69e7aa0b702ed9ed611b1dc8924f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::deque&lt;T&gt;</code> in order.  <a href="#a9f69e7aa0b702ed9ed611b1dc8924f53">More...</a><br /></td></tr>
<tr class="separator:a9f69e7aa0b702ed9ed611b1dc8924f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6d5c159456a5fe32760b642506cad8"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a0a6d5c159456a5fe32760b642506cad8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a0a6d5c159456a5fe32760b642506cad8">to_deque</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a0a6d5c159456a5fe32760b642506cad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::deque&lt;T, Allocator&gt;</code> in order.  <a href="#a0a6d5c159456a5fe32760b642506cad8">More...</a><br /></td></tr>
<tr class="separator:a0a6d5c159456a5fe32760b642506cad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cb281944a17abb919efac5d789999e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a35cb281944a17abb919efac5d789999e">to_forward_list</a> ()</td></tr>
<tr class="memdesc:a35cb281944a17abb919efac5d789999e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::forward_list&lt;T&gt;</code> in reverse order.  <a href="#a35cb281944a17abb919efac5d789999e">More...</a><br /></td></tr>
<tr class="separator:a35cb281944a17abb919efac5d789999e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ac4e649cbf6e807c5b3fc172e5f32f"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a75ac4e649cbf6e807c5b3fc172e5f32f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a75ac4e649cbf6e807c5b3fc172e5f32f">to_forward_list</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a75ac4e649cbf6e807c5b3fc172e5f32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::forward_list&lt;T, Allocator&gt;</code> in reverse order.  <a href="#a75ac4e649cbf6e807c5b3fc172e5f32f">More...</a><br /></td></tr>
<tr class="separator:a75ac4e649cbf6e807c5b3fc172e5f32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9deb512a0f643dfc551e4ffd16c60453"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a9deb512a0f643dfc551e4ffd16c60453"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9deb512a0f643dfc551e4ffd16c60453">to_group</a> (UnaryFunction classifier)</td></tr>
<tr class="memdesc:a9deb512a0f643dfc551e4ffd16c60453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream in a <code>std::map&lt;K, std::vector&lt;T&gt;&gt;</code>, where <code>K</code> is the result type of <em>classifier</em> .  <a href="#a9deb512a0f643dfc551e4ffd16c60453">More...</a><br /></td></tr>
<tr class="separator:a9deb512a0f643dfc551e4ffd16c60453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d9ff6882dec88df1da9db8858a8e2e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a64d9ff6882dec88df1da9db8858a8e2e">to_list</a> ()</td></tr>
<tr class="memdesc:a64d9ff6882dec88df1da9db8858a8e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::list&lt;T&gt;</code> in order.  <a href="#a64d9ff6882dec88df1da9db8858a8e2e">More...</a><br /></td></tr>
<tr class="separator:a64d9ff6882dec88df1da9db8858a8e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226ef35682dc28c41693bfabbb73b806"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a226ef35682dc28c41693bfabbb73b806"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a226ef35682dc28c41693bfabbb73b806">to_list</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a226ef35682dc28c41693bfabbb73b806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::list&lt;T, Allocator&gt;</code> in order.  <a href="#a226ef35682dc28c41693bfabbb73b806">More...</a><br /></td></tr>
<tr class="separator:a226ef35682dc28c41693bfabbb73b806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca68a0c6feaa53446364357148a9b52"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aaca68a0c6feaa53446364357148a9b52">to_map</a> ()</td></tr>
<tr class="memdesc:aaca68a0c6feaa53446364357148a9b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::map&lt;T, std::size_t&gt;</code>.  <a href="#aaca68a0c6feaa53446364357148a9b52">More...</a><br /></td></tr>
<tr class="separator:aaca68a0c6feaa53446364357148a9b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb29362efc30df9f7f40627bc28d8fa"><td class="memTemplParams" colspan="2">template&lt;typename KeyCompare &gt; </td></tr>
<tr class="memitem:a5fb29362efc30df9f7f40627bc28d8fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a5fb29362efc30df9f7f40627bc28d8fa">to_map</a> (KeyCompare key_compare)</td></tr>
<tr class="memdesc:a5fb29362efc30df9f7f40627bc28d8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::map&lt;T, std::size_t, KeyCompare&gt;</code>.  <a href="#a5fb29362efc30df9f7f40627bc28d8fa">More...</a><br /></td></tr>
<tr class="separator:a5fb29362efc30df9f7f40627bc28d8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcacc54b586fb6f7109e9eafb827f4f"><td class="memTemplParams" colspan="2">template&lt;typename KeyCompare , typename Allocator &gt; </td></tr>
<tr class="memitem:a8dcacc54b586fb6f7109e9eafb827f4f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a8dcacc54b586fb6f7109e9eafb827f4f">to_map</a> (KeyCompare key_compare, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a8dcacc54b586fb6f7109e9eafb827f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::map&lt;T, std::size_t, KeyCompare, Allocator&gt;</code>.  <a href="#a8dcacc54b586fb6f7109e9eafb827f4f">More...</a><br /></td></tr>
<tr class="separator:a8dcacc54b586fb6f7109e9eafb827f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd4938a06689d3fb2c137bf8eca77e1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afbd4938a06689d3fb2c137bf8eca77e1">to_multiset</a> ()</td></tr>
<tr class="memdesc:afbd4938a06689d3fb2c137bf8eca77e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::multiset&lt;T&gt;</code>.  <a href="#afbd4938a06689d3fb2c137bf8eca77e1">More...</a><br /></td></tr>
<tr class="separator:afbd4938a06689d3fb2c137bf8eca77e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986c64c957274751366cb8a0c9b8107a"><td class="memTemplParams" colspan="2">template&lt;typename Compare &gt; </td></tr>
<tr class="memitem:a986c64c957274751366cb8a0c9b8107a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a986c64c957274751366cb8a0c9b8107a">to_multiset</a> (Compare compare)</td></tr>
<tr class="memdesc:a986c64c957274751366cb8a0c9b8107a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::multiset&lt;T, Compare&gt;</code>.  <a href="#a986c64c957274751366cb8a0c9b8107a">More...</a><br /></td></tr>
<tr class="separator:a986c64c957274751366cb8a0c9b8107a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7db31d2cf47771a86218a49e8a5948"><td class="memTemplParams" colspan="2">template&lt;typename Compare , typename Allocator &gt; </td></tr>
<tr class="memitem:aef7db31d2cf47771a86218a49e8a5948"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aef7db31d2cf47771a86218a49e8a5948">to_multiset</a> (Compare compare, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:aef7db31d2cf47771a86218a49e8a5948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::multiset&lt;T, Compare, Allocator&gt;</code>.  <a href="#aef7db31d2cf47771a86218a49e8a5948">More...</a><br /></td></tr>
<tr class="separator:aef7db31d2cf47771a86218a49e8a5948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e813962b033f984b9265ebe1cccf6ee"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a1e813962b033f984b9265ebe1cccf6ee">to_set</a> ()</td></tr>
<tr class="memdesc:a1e813962b033f984b9265ebe1cccf6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::set&lt;T&gt;</code>.  <a href="#a1e813962b033f984b9265ebe1cccf6ee">More...</a><br /></td></tr>
<tr class="separator:a1e813962b033f984b9265ebe1cccf6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0029787ab7a32a1e95cce8f36c04233b"><td class="memTemplParams" colspan="2">template&lt;typename Compare &gt; </td></tr>
<tr class="memitem:a0029787ab7a32a1e95cce8f36c04233b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a0029787ab7a32a1e95cce8f36c04233b">to_set</a> (Compare compare)</td></tr>
<tr class="memdesc:a0029787ab7a32a1e95cce8f36c04233b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::set&lt;T, Compare&gt;</code>.  <a href="#a0029787ab7a32a1e95cce8f36c04233b">More...</a><br /></td></tr>
<tr class="separator:a0029787ab7a32a1e95cce8f36c04233b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af476d5605e9d8316ac0c8dcc876188a5"><td class="memTemplParams" colspan="2">template&lt;typename Compare , typename Allocator &gt; </td></tr>
<tr class="memitem:af476d5605e9d8316ac0c8dcc876188a5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#af476d5605e9d8316ac0c8dcc876188a5">to_set</a> (Compare compare, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:af476d5605e9d8316ac0c8dcc876188a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::set&lt;T, Compare, Allocator&gt;</code>.  <a href="#af476d5605e9d8316ac0c8dcc876188a5">More...</a><br /></td></tr>
<tr class="separator:af476d5605e9d8316ac0c8dcc876188a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ea8234ca26319428a71b1595d377a0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a90ea8234ca26319428a71b1595d377a0">to_unordered_map</a> ()</td></tr>
<tr class="memdesc:a90ea8234ca26319428a71b1595d377a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_map&lt;T, std::size_t&gt;</code>.  <a href="#a90ea8234ca26319428a71b1595d377a0">More...</a><br /></td></tr>
<tr class="separator:a90ea8234ca26319428a71b1595d377a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e793a030ba73a54fe954ec4429231ad"><td class="memTemplParams" colspan="2">template&lt;typename Hash &gt; </td></tr>
<tr class="memitem:a7e793a030ba73a54fe954ec4429231ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a7e793a030ba73a54fe954ec4429231ad">to_unordered_map</a> (const Hash &amp;hash)</td></tr>
<tr class="memdesc:a7e793a030ba73a54fe954ec4429231ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_map&lt;T, std::size_t, Hash&gt;</code>.  <a href="#a7e793a030ba73a54fe954ec4429231ad">More...</a><br /></td></tr>
<tr class="separator:a7e793a030ba73a54fe954ec4429231ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53348532c7654a7f0164f22f98444e9a"><td class="memTemplParams" colspan="2">template&lt;typename Hash , typename EqualPredicate &gt; </td></tr>
<tr class="memitem:a53348532c7654a7f0164f22f98444e9a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a53348532c7654a7f0164f22f98444e9a">to_unordered_map</a> (const Hash &amp;hash, EqualPredicate equal)</td></tr>
<tr class="memdesc:a53348532c7654a7f0164f22f98444e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_map&lt;T, std::size_t, Hash, EqualPredicate&gt;</code>.  <a href="#a53348532c7654a7f0164f22f98444e9a">More...</a><br /></td></tr>
<tr class="separator:a53348532c7654a7f0164f22f98444e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9d7306678c5cab545798fa67144fe3"><td class="memTemplParams" colspan="2">template&lt;typename Hash , typename EqualPredicate , typename Allocator &gt; </td></tr>
<tr class="memitem:a9e9d7306678c5cab545798fa67144fe3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e9d7306678c5cab545798fa67144fe3">to_unordered_map</a> (const Hash &amp;hash, EqualPredicate equal, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a9e9d7306678c5cab545798fa67144fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_map&lt;T, std::size_t, Hash, EqualPredicate, Allocator&gt;</code>.  <a href="#a9e9d7306678c5cab545798fa67144fe3">More...</a><br /></td></tr>
<tr class="separator:a9e9d7306678c5cab545798fa67144fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2326e9fec317a54a1e151a94cde753"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aba2326e9fec317a54a1e151a94cde753">to_unordered_multiset</a> ()</td></tr>
<tr class="memdesc:aba2326e9fec317a54a1e151a94cde753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_multiset&lt;T&gt;</code>.  <a href="#aba2326e9fec317a54a1e151a94cde753">More...</a><br /></td></tr>
<tr class="separator:aba2326e9fec317a54a1e151a94cde753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfedb440c13860b072c5731f8ab1d46"><td class="memTemplParams" colspan="2">template&lt;typename Hash &gt; </td></tr>
<tr class="memitem:a6cfedb440c13860b072c5731f8ab1d46"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a6cfedb440c13860b072c5731f8ab1d46">to_unordered_multiset</a> (const Hash &amp;hash)</td></tr>
<tr class="memdesc:a6cfedb440c13860b072c5731f8ab1d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_multiset&lt;T, Hash&gt;</code>.  <a href="#a6cfedb440c13860b072c5731f8ab1d46">More...</a><br /></td></tr>
<tr class="separator:a6cfedb440c13860b072c5731f8ab1d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fbd598715bc9ace15baecac72b154f"><td class="memTemplParams" colspan="2">template&lt;typename Hash , typename EqualPredicate &gt; </td></tr>
<tr class="memitem:ad3fbd598715bc9ace15baecac72b154f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad3fbd598715bc9ace15baecac72b154f">to_unordered_multiset</a> (const Hash &amp;hash, EqualPredicate equal)</td></tr>
<tr class="memdesc:ad3fbd598715bc9ace15baecac72b154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_multiset&lt;T, Hash, EqualPredicate&gt;</code>.  <a href="#ad3fbd598715bc9ace15baecac72b154f">More...</a><br /></td></tr>
<tr class="separator:ad3fbd598715bc9ace15baecac72b154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dc941b1b4aeac95b072216a663057e"><td class="memTemplParams" colspan="2">template&lt;typename Hash , typename EqualPredicate , typename Allocator &gt; </td></tr>
<tr class="memitem:aa4dc941b1b4aeac95b072216a663057e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aa4dc941b1b4aeac95b072216a663057e">to_unordered_multiset</a> (const Hash &amp;hash, EqualPredicate equal, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:aa4dc941b1b4aeac95b072216a663057e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_multiset&lt;T, Hash, EqualPredicate, Allocator&gt;</code>.  <a href="#aa4dc941b1b4aeac95b072216a663057e">More...</a><br /></td></tr>
<tr class="separator:aa4dc941b1b4aeac95b072216a663057e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d5aa7c8fa867dceca1bbca79e2ac1a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ab6d5aa7c8fa867dceca1bbca79e2ac1a">to_unordered_set</a> ()</td></tr>
<tr class="memdesc:ab6d5aa7c8fa867dceca1bbca79e2ac1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_set&lt;T&gt;</code>.  <a href="#ab6d5aa7c8fa867dceca1bbca79e2ac1a">More...</a><br /></td></tr>
<tr class="separator:ab6d5aa7c8fa867dceca1bbca79e2ac1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bc84b6fa611511105abe67f63ff983"><td class="memTemplParams" colspan="2">template&lt;typename Hash &gt; </td></tr>
<tr class="memitem:ae6bc84b6fa611511105abe67f63ff983"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae6bc84b6fa611511105abe67f63ff983">to_unordered_set</a> (const Hash &amp;hash)</td></tr>
<tr class="memdesc:ae6bc84b6fa611511105abe67f63ff983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_set&lt;T, Hash&gt;</code>.  <a href="#ae6bc84b6fa611511105abe67f63ff983">More...</a><br /></td></tr>
<tr class="separator:ae6bc84b6fa611511105abe67f63ff983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e4dba597728fea66fd360b4ad69791"><td class="memTemplParams" colspan="2">template&lt;typename Hash , typename EqualPredicate &gt; </td></tr>
<tr class="memitem:af4e4dba597728fea66fd360b4ad69791"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#af4e4dba597728fea66fd360b4ad69791">to_unordered_set</a> (const Hash &amp;hash, EqualPredicate equal)</td></tr>
<tr class="memdesc:af4e4dba597728fea66fd360b4ad69791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_set&lt;T, Hash, EqualPredicate&gt;</code>.  <a href="#af4e4dba597728fea66fd360b4ad69791">More...</a><br /></td></tr>
<tr class="separator:af4e4dba597728fea66fd360b4ad69791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969446e33e7a16cfcbf417c42eaab3ba"><td class="memTemplParams" colspan="2">template&lt;typename Hash , typename EqualPredicate , typename Allocator &gt; </td></tr>
<tr class="memitem:a969446e33e7a16cfcbf417c42eaab3ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a969446e33e7a16cfcbf417c42eaab3ba">to_unordered_set</a> (const Hash &amp;hash, EqualPredicate equal, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a969446e33e7a16cfcbf417c42eaab3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::unordered_set&lt;T, Hash, EqualPredicate, Allocator&gt;</code>.  <a href="#a969446e33e7a16cfcbf417c42eaab3ba">More...</a><br /></td></tr>
<tr class="separator:a969446e33e7a16cfcbf417c42eaab3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65b798b18b47576c1ffed6f63814fc0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae65b798b18b47576c1ffed6f63814fc0">to_vector</a> ()</td></tr>
<tr class="memdesc:ae65b798b18b47576c1ffed6f63814fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::vector&lt;T&gt;</code> in order.  <a href="#ae65b798b18b47576c1ffed6f63814fc0">More...</a><br /></td></tr>
<tr class="separator:ae65b798b18b47576c1ffed6f63814fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f68b3569f0a73e2bbc6e42d83bbe85"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a67f68b3569f0a73e2bbc6e42d83bbe85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a67f68b3569f0a73e2bbc6e42d83bbe85">to_vector</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a67f68b3569f0a73e2bbc6e42d83bbe85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the stream into a <code>std::vector&lt;T, Allocator&gt;</code> in order.  <a href="#a67f68b3569f0a73e2bbc6e42d83bbe85">More...</a><br /></td></tr>
<tr class="separator:a67f68b3569f0a73e2bbc6e42d83bbe85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Terminal operations, all of which are also aliased in the flow namespace. </p>
<p>The functions in the <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html" title="Terminal operations, all of which are also aliased in the flow namespace. ">flow::terminal</a> namespace all produce a terminal operation. The terminal operation does not operate on a stream until the pipe <code>operator|</code> has been applied, after which the stream is evaluated and the terminal's return value is calculated.</p>
<p>Some terminal operations (such as <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad02d008becaf1d5d64d2ae358ae7306e" title="Returns the minimum element from the stream as an optional according to compare , operator< by defaul...">min()</a>) return an <a class="el" href="../../d6/d3f/classflow_1_1optional.html">optional</a> object when the stream is empty. This method was chosen over throwing an exception, though there is no clear better way. In the end, flow uses the optional class for the following reasons:</p>
<ul>
<li>
In the exceptional case, a boolean check is much faster than an exception. </li>
<li>
In many cases, you will know for sure that the optional returned contains a value and the boolean check can be skipped anyways. Consider that many of the STL algorithms return iterators which are commonly used without checking them for validity. </li>
<li>
In other cases, when you don't know for sure if a value would exist, a boolean check only carries a very slight overhead. </li>
<li>
It is less code on the user end which is always nice. </li>
</ul>
<p>Some convenience methods are available to Terminal operations:</p>
<div class="fragment"><div class="line">Terminal&lt;F&gt; then(F f);      <span class="comment">// a terminal which applies f to the result of this terminal</span></div>
<div class="line">Terminal&lt;?&gt; value();        <span class="comment">// a terminal which directly accesses the optional&#39;s contained value, undefined if the optional has no value</span></div>
<div class="line">Terminal&lt;?&gt; value_or(U&amp;&amp;);  <span class="comment">// a terminal which directly calls optional::value_or</span></div>
<div class="line">Terminal&lt;?&gt; if_then(F f, G g = [](){}); <span class="comment">// a terminal which applies f to the contained optional value if it is present, otherwise g is applied </span></div>
</div><!-- fragment --> <p>Examples of these operations are available in <a class="el" href="../../df/de0/terminal_8cpp-example.html">terminal.cpp</a>.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000003">Todo:</a></b></dt><dd><p class="startdd">parallel_*() - chunking parallelization of terminal operations </p>
<p>parallel pipelining of stream operations? </p>
<p>equals - check if two streams are equal </p>
<p>find - filter(equal to) | <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae2088cf5443957cdf935652bccc0b612" title="Returns the first element from the stream as an optional. ">first()</a>; optional parameter to return if filtered stream is empty </p>
<p>is_sorted - check if a stream is sorted by a comparator </p>
<p>overload comparison operators between streams? </p>
<p class="enddd">custom - (is this better than <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a6b3d0ede6c9489aebb9ce1ed684c31a0" title="Executes a function for each element in the stream. ">each()</a> with capture?) allow users to create their own terminal operations; useful to ensure signature takes a <code>Stream&lt;Source&gt;&amp;&amp;</code> </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>correct : <span class="keyword">public</span> correct&lt;decltype(&amp;T::operator())&gt; { }; <span class="comment">// capture lambda</span></div>
<div class="line"><span class="comment">// true types</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C, <span class="keyword">typename</span> Src&gt; <span class="keyword">struct </span>correct&lt;R(C::*)(Stream&lt;Src&gt;&amp;&amp;)&gt; : std::true_type { };    <span class="comment">// capture class functions</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Src&gt; <span class="keyword">struct </span>correct&lt;R(Stream&lt;Src&gt;&amp;&amp;)&gt; : std::true_type { };                      <span class="comment">// capture functions</span></div>
<div class="line"><span class="comment">// false types</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct </span>correct&lt;R(Args...)&gt; : std::false_type { };</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct </span>correct&lt;R(C::*)(Args...)&gt; : std::false_type { }; </div>
</div><!-- fragment --> </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afb46a36fe4c6693d7b05e3bd0fc05f4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::all </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if all of the elements in the stream return <code>true</code> for <em>predicate</em> . </p>
<p>This operation is short circuited and will stop executing once any <code>false</code> value is found. If the stream is empty, this will return <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The predicate to test each element with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which returns <code>true</code> if all stream elements return <code>true</code> for <em>predicate</em> .</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aef6844ddc5a40bb68764bc31f6070107" title="Returns true if any of the elements in the stream return true for predicate . ">any()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e6d1f983184706c6ec3a976c449ee6d" title="Returns true if none of the elements in the stream return true for predicate . ">none()</a></dd></dl>

</div>
</div>
<a class="anchor" id="ab69ca58eca0161111d95306425586634"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if all elements in the stream can be evaluated to <code>true</code>. </p>
<p>This is an overload for streams with types convertible to <code>bool</code>. This operation is short circuited and will stop executing once any <code>false</code> value is found. If the stream is empty, this will return <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which returns <code>true</code> if all stream elements are <code>true</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aef6844ddc5a40bb68764bc31f6070107" title="Returns true if any of the elements in the stream return true for predicate . ">any()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e6d1f983184706c6ec3a976c449ee6d" title="Returns true if none of the elements in the stream return true for predicate . ">none()</a></dd></dl>

</div>
</div>
<a class="anchor" id="ab756d99bb6fe64ace09d278028f0f539"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::all </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if all of the elements in the stream return <code>true</code> for <em>member</em> . </p>
<p>This operation is short circuited and will stop executing once any <code>false</code> value is found. If the stream is empty, this will return <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function to use as the predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which returns <code>true</code> if all stream element returns <code>true</code> for the given predicate.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aef6844ddc5a40bb68764bc31f6070107" title="Returns true if any of the elements in the stream return true for predicate . ">any()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e6d1f983184706c6ec3a976c449ee6d" title="Returns true if none of the elements in the stream return true for predicate . ">none()</a></dd></dl>

</div>
</div>
<a class="anchor" id="aef6844ddc5a40bb68764bc31f6070107"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::any </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if any of the elements in the stream return <code>true</code> for <em>predicate</em> . </p>
<p>This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The predicate to test each element with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which returns <code>true</code> if any stream element returns <code>true</code> for <em>predicate</em> .</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb46a36fe4c6693d7b05e3bd0fc05f4d" title="Returns true if all of the elements in the stream return true for predicate . ">all()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e6d1f983184706c6ec3a976c449ee6d" title="Returns true if none of the elements in the stream return true for predicate . ">none()</a></dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../df/de0/terminal_8cpp-example.html#a1">terminal.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af592d8f034ddf176998928a0d3b86bd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if any element in the stream can be evaluated to <code>true</code>. </p>
<p>This is an overload for streams with types convertible to <code>bool</code>. This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which returns <code>true</code> if any stream element is <code>true</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb46a36fe4c6693d7b05e3bd0fc05f4d" title="Returns true if all of the elements in the stream return true for predicate . ">all()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e6d1f983184706c6ec3a976c449ee6d" title="Returns true if none of the elements in the stream return true for predicate . ">none()</a></dd></dl>

</div>
</div>
<a class="anchor" id="aed588ae01b14be839486b94bb87f2ed8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::any </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if any of the elements in the stream return <code>true</code> for <em>member</em> . </p>
<p>This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function to use as the predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which returns <code>true</code> if any stream element returns <code>true</code> for the given predicate.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb46a36fe4c6693d7b05e3bd0fc05f4d" title="Returns true if all of the elements in the stream return true for predicate . ">all()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e6d1f983184706c6ec3a976c449ee6d" title="Returns true if none of the elements in the stream return true for predicate . ">none()</a></dd></dl>

</div>
</div>
<a class="anchor" id="afc94fb24c31b8f7e46d8603a6997589b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::contains </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an element in the stream compares equal to <code>val</code> by <code>operator==</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to search for in the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which returns <code>true</code> if the stream contains <code>val</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="aa2e701e11c61d1038e3b0581e2f32df0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::copy </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements in the stream into the range beginning at <code>result</code>. </p>
<p>An iterator to the end of the destination range is returned, pointing to the element after the last element copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output iterator to the initial position in the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into the <code>result</code> range.</dd></dl>

</div>
</div>
<a class="anchor" id="a52dfcc0ff79f7c3d74ea2e80a3f9a65f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the stream as <code>std::size_t</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which counts the number of elements in the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e6b4fef03bc255768e41ab77d3b36ef" title="Returns the number of elements in the stream that return true for predicate  as std::size_t. ">count_if()</a></dd></dl>

</div>
</div>
<a class="anchor" id="af6459123c95b8fd67a2771d63addf036"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::count </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of the occurrences of <em>value</em>  in the stream as <code>std::size_t</code>. </p>
<p>Equality is checking using <code>operator==</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which counts of the occurrences of <em>value</em>  in the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9e6b4fef03bc255768e41ab77d3b36ef" title="Returns the number of elements in the stream that return true for predicate  as std::size_t. ">count_if()</a>, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afc94fb24c31b8f7e46d8603a6997589b" title="Returns true if an element in the stream compares equal to val by operator==. ">contains()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a9e6b4fef03bc255768e41ab77d3b36ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::count_if </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the stream that return <code>true</code> for <em>predicate</em>  as <code>std::size_t</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which counts the number of elements in the stream that return <code>true</code> for <em>predicate</em> .</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a52dfcc0ff79f7c3d74ea2e80a3f9a65f" title="Returns the number of elements in the stream as std::size_t. ">count()</a>, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a></dd></dl>

</div>
</div>
<a class="anchor" id="acc0afd1d9f8846d76814248e4d6a164f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the stream elements to <em>out</em>  with <em>delimiter</em>  printed after each element. </p>
<p>A reference to the output stream is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream to print to.</td></tr>
    <tr><td class="paramname">delimiter</td><td>The delimiter to add after each element, by default a single space is added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which print the stream elements to <em>out</em> .</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d7/db4/concat_8cpp-example.html#a2">concat.cpp</a>, <a class="el" href="../../df/d73/drop_while_8cpp-example.html#a2">drop_while.cpp</a>, and <a class="el" href="../../d0/d76/zip_8cpp-example.html#a2">zip.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6b3d0ede6c9489aebb9ce1ed684c31a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::each </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a function for each element in the stream. </p>
<p>The executed function is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to apply to each element of the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation that executes a function for each stream element.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac9078ec57972888d23411f8c3ea209af" title="Executes action  for each element in the stream. ">peek()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a89c7d99f1f196e5f9b55032c60097ece"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::each </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the member function for each element in the stream. </p>
<p>The executed function is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function to use as the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation that executes a member function for each stream element.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac9078ec57972888d23411f8c3ea209af" title="Executes action  for each element in the stream. ">peek()</a></dd></dl>

</div>
</div>
<a class="anchor" id="afc1e1a50b753d81652abaa28a9292eb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::execute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the stream to be evaluated entirely. </p>
<p>The stream will not normally be evaluated unless a terminal operation or an eager intermediate operation is applied. This terminal forces evaluation of the entire stream. For example:</p>
<p><code>widgets | zip(iota(1), [](Widget&amp; w, int i) { w.set_id(i); return i; });</code> </p>
<p>The above stream assigns a unique id to each Widget, and the stream contains the ids. However, no terminal operation is applied, no value is ever needed so none of the stream is ever evaluated. Appending <code> | <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afc1e1a50b753d81652abaa28a9292eb4" title="Forces the stream to be evaluated entirely. ">execute()</a></code> will force the stream to be evaluated, assigning the ids but ignoring the stream itself.</p>
<dl class="section return"><dt>Returns</dt><dd>A detail::Terminal operation that evaluates the entire stream but ignores the elements.</dd></dl>

</div>
</div>
<a class="anchor" id="ae2088cf5443957cdf935652bccc0b612"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first element from the stream as an optional. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which gives the first element from the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9eb644e7c13c0b2805f1e565763285da" title="Returns the nth element from the stream as an optional. ">nth()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a4fe0dda56d4f64d94e607e73b9187960" title="Returns the last element from the stream as an optional. ">last()</a>, <a class="el" href="../../d6/d3f/classflow_1_1optional.html" title="Manages an optionally contained value, one that may or may not be present. ">optional</a></dd></dl>

</div>
</div>
<a class="anchor" id="ad76999f9b4b01425b09c070cc7154ec8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accumulator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::fold </td>
          <td>(</td>
          <td class="paramtype">Accumulator&#160;</td>
          <td class="paramname"><em>accumulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Folds the stream using the <em>accumulator</em> . </p>
<p>This operation is equivalent to</p>
<p><code>for (T e : stream) { init = accumulator(init, e); }</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accumulator</td><td>The function through which the stream is folded.</td></tr>
    <tr><td class="paramname">init</td><td>The initial value to start the folding operation at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which folds the stream.</dd></dl>

</div>
</div>
<a class="anchor" id="aabf7db53b2573f8f651420cc508170f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accumulator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::fold </td>
          <td>(</td>
          <td class="paramtype">Accumulator&#160;</td>
          <td class="paramname"><em>accumulator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Folds the stream using <em>accumulator</em> , returning the value as an optional. </p>
<p>The first element of the stream is used for the initial folding value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accumulator</td><td>The function through which the stream is folded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which folds the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d3f/classflow_1_1optional.html" title="Manages an optionally contained value, one that may or may not be present. ">optional</a></dd></dl>

</div>
</div>
<a class="anchor" id="a71feb02eace70a6babe98181f1e7c579"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accumulator , typename UnaryFunction , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::fold_id </td>
          <td>(</td>
          <td class="paramtype">Accumulator&#160;</td>
          <td class="paramname"><em>accumulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>initializer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Folds the stream using <em>accumulator</em> . </p>
<p>The result of <em>initializer</em>  applied to <em>init</em>  is used for the initial folding value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accumulator</td><td>The accumulator, the function through which the stream is folded.</td></tr>
    <tr><td class="paramname">initializer</td><td>The initializer function to apply to the first element in the stream.</td></tr>
    <tr><td class="paramname">init</td><td>The initial value to start the folding operation at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which folds the stream.</dd></dl>

</div>
</div>
<a class="anchor" id="a439e3f4a1be79bae0105092613415773"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Accumulator , typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::fold_id </td>
          <td>(</td>
          <td class="paramtype">Accumulator&#160;</td>
          <td class="paramname"><em>accumulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>initializer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Folds the stream using <em>accumulator</em> , returning the value as an optional. </p>
<p>The result of <em>initializer</em>  applied to the first element of the stream is used for the initial folding value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accumulator</td><td>The function through which the stream is folded.</td></tr>
    <tr><td class="paramname">initializer</td><td>The initializer function to apply to the first element in the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which folds the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d3f/classflow_1_1optional.html" title="Manages an optionally contained value, one that may or may not be present. ">optional</a></dd></dl>

</div>
</div>
<a class="anchor" id="a338ea201d1ada38a3c2afec6944fbc42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source , typename T , typename ProductFunction  = std::multiplies&lt;void&gt;, typename SumFunction  = std::plus&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::inner_product </td>
          <td>(</td>
          <td class="paramtype">Stream&lt; Source &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProductFunction&#160;</td>
          <td class="paramname"><em>times</em> = <code>ProductFunction()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SumFunction&#160;</td>
          <td class="paramname"><em>plus</em> = <code>SumFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inner product (also known as dot product) of the two streams. </p>
<p>The inner product is the sum of products of the elements of the two streams. If the streams are not the same length, the calculation stops once the shorter of the two streams is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right stream to compute the inner product with.</td></tr>
    <tr><td class="paramname">value</td><td>The starting value for the summation, defaults to <code>T()</code>.</td></tr>
    <tr><td class="paramname">times</td><td>The multiplication operation, defaults to <code>operator*</code>.</td></tr>
    <tr><td class="paramname">plus</td><td>The addition operation, defaults to <code>operator+</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inner product between <em>right</em>  and the operated stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ad24663e241e18fe008f4bb9a7d1c0bfc" title="Zips the two streams together using zipper  as the zipping operation. ">zip()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad76999f9b4b01425b09c070cc7154ec8" title="Folds the stream using the accumulator . ">fold()</a></dd></dl>

</div>
</div>
<a class="anchor" id="aaa80485667da9ab8a6cfdf4651a87150"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Itr , typename T , typename ProductFunction  = std::multiplies&lt;void&gt;, typename SumFunction  = std::plus&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::inner_product </td>
          <td>(</td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProductFunction&#160;</td>
          <td class="paramname"><em>times</em> = <code>ProductFunction()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SumFunction&#160;</td>
          <td class="paramname"><em>plus</em> = <code>SumFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inner product (also known as dot product) of the stream and iterator range, this is the same as <code>inner_product(from(begin, end), value, times, plus)</code>. </p>
<p>The inner product is the sum of products of the elements of the stream and iterator range. If they are not the same length, the calculation stops once the shorter of the two is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the range to compute inner product with.</td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to compute inner product with.</td></tr>
    <tr><td class="paramname">value</td><td>The starting value for the summation, defaults to <code>T()</code>.</td></tr>
    <tr><td class="paramname">times</td><td>The multiplication operation, defaults to <code>operator*</code>.</td></tr>
    <tr><td class="paramname">plus</td><td>The addition operation, defaults to <code>operator+</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inner product between <code>[begin, end)</code> and the operated stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ad24663e241e18fe008f4bb9a7d1c0bfc" title="Zips the two streams together using zipper  as the zipping operation. ">zip()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad76999f9b4b01425b09c070cc7154ec8" title="Folds the stream using the accumulator . ">fold()</a>, <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a21f4741c21faf2386a61774ba5eee6a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T , typename ProductFunction  = std::multiplies&lt;void&gt;, typename SumFunction  = std::plus&lt;T&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::inner_product </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProductFunction&#160;</td>
          <td class="paramname"><em>times</em> = <code>ProductFunction()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SumFunction&#160;</td>
          <td class="paramname"><em>plus</em> = <code>SumFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inner product (also known as dot product) of the stream and <em>container</em> , this is the same as <code>inner_product(from(container), value, times, plus)</code>. </p>
<p>The inner product is the sum of products of the elements of the stream and <em>container</em> . If they are not the same length, the calculation stops once the shorter of the two is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to compute the inner product with.</td></tr>
    <tr><td class="paramname">value</td><td>The starting value for the summation, defaults to <code>T()</code>.</td></tr>
    <tr><td class="paramname">times</td><td>The multiplication operation, defaults to <code>operator*</code>.</td></tr>
    <tr><td class="paramname">plus</td><td>The addition operation, defaults to <code>operator+</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inner product between <em>container</em>  and the operated stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ad24663e241e18fe008f4bb9a7d1c0bfc" title="Zips the two streams together using zipper  as the zipping operation. ">zip()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad76999f9b4b01425b09c070cc7154ec8" title="Folds the stream using the accumulator . ">fold()</a>, <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a3a1febd32cb8ca10885dcffff7861b26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename ProductFunction  = std::multiplies&lt;void&gt;, typename SumFunction  = std::plus&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::inner_product </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProductFunction&#160;</td>
          <td class="paramname"><em>times</em> = <code>ProductFunction()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SumFunction&#160;</td>
          <td class="paramname"><em>plus</em> = <code>SumFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inner product (also known as dot product) of the stream and <em>list</em> , this is the same as <code>inner_product(from(list), value, times, plus)</code>. </p>
<p>The inner product is the sum of products of the elements of the stream and <em>list</em> . If they are not the same length, the calculation stops once the shorter of the two is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to compute the inner product with.</td></tr>
    <tr><td class="paramname">value</td><td>The starting value for the summation, defaults to <code>T()</code>.</td></tr>
    <tr><td class="paramname">times</td><td>The multiplication operation, defaults to <code>operator*</code>.</td></tr>
    <tr><td class="paramname">plus</td><td>The addition operation, defaults to <code>operator+</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inner product between <em>list</em>  and the operated stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ad24663e241e18fe008f4bb9a7d1c0bfc" title="Zips the two streams together using zipper  as the zipping operation. ">zip()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad76999f9b4b01425b09c070cc7154ec8" title="Folds the stream using the accumulator . ">fold()</a>, <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a4fe0dda56d4f64d94e607e73b9187960"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last element from the stream as an optional. </p>
<p>This is a potentially expensive operation as the entire stream must be evaluated.</p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which gives the last element from the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae2088cf5443957cdf935652bccc0b612" title="Returns the first element from the stream as an optional. ">first()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9eb644e7c13c0b2805f1e565763285da" title="Returns the nth element from the stream as an optional. ">nth()</a>, <a class="el" href="../../d6/d3f/classflow_1_1optional.html" title="Manages an optionally contained value, one that may or may not be present. ">optional</a></dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000005">Todo:</a></b></dt><dd>is there a way to lazily step to the end of the stream? </dd></dl>

</div>
</div>
<a class="anchor" id="aa878b5ae4e25bf654161a5004ca025b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::max </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum element from the stream as an optional according to <em>compare</em> , <code>operator&lt;</code> by default. </p>
<p>If there are multiple maximum elements, the first such element is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The compare function, by default <code>std::less&lt;void&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A detail::Terminal operation which gives the maximum element from the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad02d008becaf1d5d64d2ae358ae7306e" title="Returns the minimum element from the stream as an optional according to compare , operator< by defaul...">min()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae944c0b98f14746eb980b9883e36a7e4" title="Returns the minimum and maximum elements as a optional pair from the stream according to compare ...">minmax()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a900a16920892b0445f890cad56458c9a" title="Returns a Stats object which contains several statistics of the stream values. ">stats()</a>, <a class="el" href="../../d6/d3f/classflow_1_1optional.html" title="Manages an optionally contained value, one that may or may not be present. ">optional</a></dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../df/de0/terminal_8cpp-example.html#a4">terminal.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad02d008becaf1d5d64d2ae358ae7306e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::min </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum element from the stream as an optional according to <em>compare</em> , <code>operator&lt;</code> by default. </p>
<p>If there are multiple minimum elements, the first such element is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The compare function, by default <code>std::less&lt;void&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A detail::Terminal operation which gives the minimum element from the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aa878b5ae4e25bf654161a5004ca025b3" title="Returns the maximum element from the stream as an optional according to compare , operator< by defaul...">max()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae944c0b98f14746eb980b9883e36a7e4" title="Returns the minimum and maximum elements as a optional pair from the stream according to compare ...">minmax()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a900a16920892b0445f890cad56458c9a" title="Returns a Stats object which contains several statistics of the stream values. ">stats()</a>, <a class="el" href="../../d6/d3f/classflow_1_1optional.html" title="Manages an optionally contained value, one that may or may not be present. ">optional</a></dd></dl>

</div>
</div>
<a class="anchor" id="ae944c0b98f14746eb980b9883e36a7e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::minmax </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum and maximum elements as a optional pair from the stream according to <em>compare</em> , <code>operator&lt;</code> by default. </p>
<p>The first element is the minimum and the second element is the maximum. If there are multiple min/max elements, the <em>first</em> minimum element and the <em>last</em> maximum element are returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The compare function, by default <code>std::less&lt;void&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A detail::Terminal operation which gives the min and max elements from the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ad02d008becaf1d5d64d2ae358ae7306e" title="Returns the minimum element from the stream as an optional according to compare , operator< by defaul...">min()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aa878b5ae4e25bf654161a5004ca025b3" title="Returns the maximum element from the stream as an optional according to compare , operator< by defaul...">max()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a900a16920892b0445f890cad56458c9a" title="Returns a Stats object which contains several statistics of the stream values. ">stats()</a>, <a class="el" href="../../d6/d3f/classflow_1_1optional.html" title="Manages an optionally contained value, one that may or may not be present. ">optional</a></dd></dl>

</div>
</div>
<a class="anchor" id="a9e6d1f983184706c6ec3a976c449ee6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::none </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if none of the elements in the stream return <code>true</code> for <em>predicate</em> . </p>
<p>This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The predicate to test each element with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which returns <code>true</code> if none of stream elements return <code>true</code> for <em>predicate</em> .</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb46a36fe4c6693d7b05e3bd0fc05f4d" title="Returns true if all of the elements in the stream return true for predicate . ">all()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aef6844ddc5a40bb68764bc31f6070107" title="Returns true if any of the elements in the stream return true for predicate . ">any()</a></dd></dl>

</div>
</div>
<a class="anchor" id="ae4c81d966a9a314a18cc091bbca744fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if none of the elements in the stream can be evaluated to <code>true</code>. </p>
<p>This is an overload for streams with types convertible to <code>bool</code>. This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which returns <code>true</code> if none of the stream elements are <code>true</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb46a36fe4c6693d7b05e3bd0fc05f4d" title="Returns true if all of the elements in the stream return true for predicate . ">all()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aef6844ddc5a40bb68764bc31f6070107" title="Returns true if any of the elements in the stream return true for predicate . ">any()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a774947b90963349171b7964c524fb23a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::none </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if none of the elements in the stream return <code>true</code> for <em>member</em> . </p>
<p>This operation is short circuited and will stop executing once any <code>true</code> value is found. If the stream is empty, this will return <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function to use as the predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which returns <code>true</code> if none of the stream elements return <code>true</code> for <em>member</em> .</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb46a36fe4c6693d7b05e3bd0fc05f4d" title="Returns true if all of the elements in the stream return true for predicate . ">all()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aef6844ddc5a40bb68764bc31f6070107" title="Returns true if any of the elements in the stream return true for predicate . ">any()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a9eb644e7c13c0b2805f1e565763285da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::nth </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth element from the stream as an optional. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which gives the nth element from the stream.</dd></dl>

</div>
</div>
<a class="anchor" id="adc89d6fdbd682554a03d621d57dc0e19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::product </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the product of all the elements in the stream using <code>operator*</code> as an optional. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which multiplies the elements in the stream.</dd></dl>

</div>
</div>
<a class="anchor" id="ac41837040615447514b15b28c578d829"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::product </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the product of all the elements in the stream using <code>operator*</code>, starting the product at <em>init</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The initial value to start the product at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which multiplies the elements in the stream.</dd></dl>

</div>
</div>
<a class="anchor" id="afb323e26fb0ea79bd18bba9edfd8ec86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::reservoir </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>execution_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random sample from the potentially infinite stream in a <code>std::vector</code>. </p>
<p>For infinite streams, execution stops once <em>execution_limit</em>  stream elements have been seen. For finite streams, execution stops once <em>execution_limit</em>  stream elements have been seen or once the stream has ended, whichever comes first.</p>
<p>Each element in the stream has a <code>1 / min(stream_size, execution_limit)</code> chance to appear in the returned sample.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to obtain from the stream. If the stream is smaller, all elements are returned.</td></tr>
    <tr><td class="paramname">execution_limit</td><td>Once this many stream elements have been seen, a sample is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A detail::Terminal operation that returns a <code>std::vector</code> of <em>n</em>  random stream elements.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae875fa53b5a07351a74291d1814e5eb3" title="Returns a random sample from the finite stream in a std::vector. ">sample()</a></dd></dl>

</div>
</div>
<a class="anchor" id="aa44a519f0dc4368647050c9b1857dd40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::reservoir </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random sample from the potentially infinite stream in a <code>std::vector</code>. </p>
<p>For infinite streams, execution stops once 16,777,216 stream elements have been seen. For finite streams, execution stops once the estimated number of stream elements have been seen or once the stream has ended, whichever comes first. The estimated size can potentially be an over- or underestimate. For known finite streams, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae875fa53b5a07351a74291d1814e5eb3" title="Returns a random sample from the finite stream in a std::vector. ">sample()</a> is a better option.</p>
<p>Each element in the stream has a <code>1 / min(stream_size, 16,777,216)</code> chance to appear in the returned sample.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to obtain from the stream. If the stream is smaller, all elements are returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A detail::Terminal operation that returns a <code>std::vector</code> of <em>n</em>  random stream elements.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae875fa53b5a07351a74291d1814e5eb3" title="Returns a random sample from the finite stream in a std::vector. ">sample()</a></dd></dl>

</div>
</div>
<a class="anchor" id="ae875fa53b5a07351a74291d1814e5eb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::sample </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random sample from the finite stream in a <code>std::vector</code>. </p>
<p>This method tries to pick the better of <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ac43d66a22a81d6c1499d6240f74f31e4" title="Returns a random sample from the finite stream in a std::vector. ">sample_heap()</a> and <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a3cad9fb8be0557995c03f1eb6045c7be" title="Returns a random sample from the finite stream in a std::vector. ">sample_shuffle()</a> using the estimated size of the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to obtain from the stream. If the stream is smaller, all elements are returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A detail::Terminal operation that returns a <code>std::vector</code> of <em>n</em>  random stream elements.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ac43d66a22a81d6c1499d6240f74f31e4" title="Returns a random sample from the finite stream in a std::vector. ">sample_heap()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a3cad9fb8be0557995c03f1eb6045c7be" title="Returns a random sample from the finite stream in a std::vector. ">sample_shuffle()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb323e26fb0ea79bd18bba9edfd8ec86" title="Returns a random sample from the potentially infinite stream in a std::vector. ">reservoir()</a></dd></dl>

</div>
</div>
<a class="anchor" id="ac43d66a22a81d6c1499d6240f74f31e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::sample_heap </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random sample from the finite stream in a <code>std::vector</code>. </p>
<p>This implementation uses a heap-sample method. </p>
<p>The heap-sample method takes <code>O(N log n)</code> time where <code>N</code> is the number of elements in the stream and <code>n</code> is the sample size parameter, <em>n</em> . This method generates a random number <code>r</code> for each stream element <code>e</code> and places the pair <code>(r, e)</code> into a heap ordered by <code>r</code>. If the heap has more than <em>n</em>  elements, a remove operation is performed on the heap. Finally, the actual elements from the heap are moved into a <code>std::vector</code>.</p>
<p>This method essentially assigns a random number to each element, and keeps the <em>n</em>  elements with the smallest number. It should be used when the sample size you want to obtain is small compared to the size of the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to obtain from the stream. If the stream is smaller, all elements are returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A detail::Terminal operation that returns a <code>std::vector</code> of <em>n</em>  random stream elements.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae875fa53b5a07351a74291d1814e5eb3" title="Returns a random sample from the finite stream in a std::vector. ">sample()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb323e26fb0ea79bd18bba9edfd8ec86" title="Returns a random sample from the potentially infinite stream in a std::vector. ">reservoir()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a3cad9fb8be0557995c03f1eb6045c7be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::sample_shuffle </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random sample from the finite stream in a <code>std::vector</code>. </p>
<p>This implementation uses a shuffle-sample method. </p>
<p>The shuffle-sample method takes <code>O(N + n)</code> time where <code>N</code> is the number of elements in the stream and <code>n</code> is the sample size parameter, <em>n</em> . This method copies the entire stream into a vector, shuffles it, then erases elements so that there are only <em>n</em>  elements. This method should be used when the sample size is relatively large.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements to obtain from the stream. If the stream is smaller, all elements are returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A detail::Terminal operation that returns a <code>std::vector</code> of <em>n</em>  random stream elements.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae875fa53b5a07351a74291d1814e5eb3" title="Returns a random sample from the finite stream in a std::vector. ">sample()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#afb323e26fb0ea79bd18bba9edfd8ec86" title="Returns a random sample from the potentially infinite stream in a std::vector. ">reservoir()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a900a16920892b0445f890cad56458c9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType  = double, bool MinMax = false, bool MedianMode = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="../../dd/d45/classflow_1_1_stats.html" title="Class to wrap all the statistics returned by stats(). ">Stats</a> object which contains several statistics of the stream values. </p>
<p>The number of elements, mean, standard deviation, variance, sum and sum of squares are always calculated.</p>
<p>Some statistical values are calculated as <code>ResultType</code>, others are calculated as <code>T</code>, the type of elements in the stream. Calculating statistics requires that both <code>T</code> and <code>ResultType</code> behave as arithmetic types (such as <code>int</code>, <code>double</code> or <code>std::complex</code>).</p>
<p>The other template parameters indicate whether or not to calculate additional statistics, all of which are not calculated by default. The behavior of each of them is as follows (<code>n</code> is the size of the stream):</p>
<ul>
<li>
<code>MinMax</code> - calculate the minimum and maximum value of the stream. The min and max are calculated as <code>T</code>. This operation uses an additional <code>2n</code> time (slower than using <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae944c0b98f14746eb980b9883e36a7e4" title="Returns the minimum and maximum elements as a optional pair from the stream according to compare ...">minmax()</a>). </li>
<li>
<code>MedianMode</code> - calculate the median, mode, and frequency of each element of the stream. The median is calculated as <code>ResultType</code>, the modes as <code>std::vector&lt;T&gt;</code>, and the frequency table as <code>std::map&lt;T, std::size_t&gt;</code>. If there is an even number of elements in the stream, the median is calculated as the average of the two possible medians. This operation uses an additional <code>O(n logn)</code> time (<code>n</code> map insertions) and <code>O(k)</code> space, where <code>k</code> is the number of distinct values in the stream. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation that calculates various statistical values of the stream.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown when the stream is empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d45/classflow_1_1_stats.html" title="Class to wrap all the statistics returned by stats(). ">Stats</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a52dfcc0ff79f7c3d74ea2e80a3f9a65f" title="Returns the number of elements in the stream as std::size_t. ">count()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381" title="Returns the sum of all the elements in the stream using operator+ as an optional. ...">sum()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae944c0b98f14746eb980b9883e36a7e4" title="Returns the minimum and maximum elements as a optional pair from the stream according to compare ...">minmax()</a>, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#aaca68a0c6feaa53446364357148a9b52" title="Copies the stream into a std::map<T, std::size_t>. ">to_map()</a></dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000006">Todo:</a></b></dt><dd>make this return an optional? </dd></dl>

</div>
</div>
<a class="anchor" id="a9d36eab187f4b501c07a00f39e4f2381"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of all the elements in the stream using <code>operator+</code> as an optional. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which sums the elements in the stream.</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../df/de0/terminal_8cpp-example.html#a2">terminal.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a21f36f6877d4af5794b93a8f1c0af92d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::sum </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of all the elements in the stream using <code>operator+</code>, starting the sum at <em>init</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The initial value to start the sum at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which sums the elements in the stream.</dd></dl>

</div>
</div>
<a class="anchor" id="a9f69e7aa0b702ed9ed611b1dc8924f53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_deque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::deque&lt;T&gt;</code> in order. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::deque</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a0a6d5c159456a5fe32760b642506cad8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_deque </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::deque&lt;T, Allocator&gt;</code> in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The allocator to use in the returned container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::deque</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a35cb281944a17abb919efac5d789999e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_forward_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::forward_list&lt;T&gt;</code> in reverse order. </p>
<p>Due to a lack of <code>forward_list::push_back</code>, the list contains the stream elements in reverse order, as they are pushed to the front of the list instead.</p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::forward_list</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a75ac4e649cbf6e807c5b3fc172e5f32f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_forward_list </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::forward_list&lt;T, Allocator&gt;</code> in reverse order. </p>
<p>Due to a lack of <code>forward_list::push_back</code>, the list contains the stream elements in reverse order, as they are pushed to the front of the list instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The allocator to use in the returned container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::forward_list</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a9deb512a0f643dfc551e4ffd16c60453"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_group </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>classifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream in a <code>std::map&lt;K, std::vector&lt;T&gt;&gt;</code>, where <code>K</code> is the result type of <em>classifier</em> . </p>
<p>The returned map groups all stream elements together which map to the same value through <em>classifier</em> . For example, the following groups all the <code>People</code> which have the same first name.</p>
<p><code>people | to_group([](Person&amp; p) { return p.first_name(); });</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">classifier</td><td>The grouping function, stream elements which return the same value will be grouped to the same key in the returned map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which groups stream elements according to <em>classifier</em> .</dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000007">Todo:</a></b></dt><dd><p class="startdd">mem_fn overloads; vc++ crashes when compiling these </p>
<p class="enddd">overload to fold the resultant groups? </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a64d9ff6882dec88df1da9db8858a8e2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::list&lt;T&gt;</code> in order. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::list</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a226ef35682dc28c41693bfabbb73b806"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_list </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::list&lt;T, Allocator&gt;</code> in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The allocator to use in the returned container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::list</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="aaca68a0c6feaa53446364357148a9b52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::map&lt;T, std::size_t&gt;</code>. </p>
<p>The map keys are stream elements and each mapped value in the number of occurrences of that key in the stream.</p>

</div>
</div>
<a class="anchor" id="a5fb29362efc30df9f7f40627bc28d8fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_map </td>
          <td>(</td>
          <td class="paramtype">KeyCompare&#160;</td>
          <td class="paramname"><em>key_compare</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::map&lt;T, std::size_t, KeyCompare&gt;</code>. </p>
<p>The map keys are stream elements and each mapped value in the number of occurrences of that key in the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_compare</td><td>The key comparator to use in the map.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8dcacc54b586fb6f7109e9eafb827f4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyCompare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_map </td>
          <td>(</td>
          <td class="paramtype">KeyCompare&#160;</td>
          <td class="paramname"><em>key_compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::map&lt;T, std::size_t, KeyCompare, Allocator&gt;</code>. </p>
<p>The map keys are stream elements and each mapped value in the number of occurrences of that key in the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_compare</td><td>The key comparator to use in the map.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use in the returned container.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbd4938a06689d3fb2c137bf8eca77e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_multiset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::multiset&lt;T&gt;</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::multiset</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a986c64c957274751366cb8a0c9b8107a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_multiset </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::multiset&lt;T, Compare&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The comparator to use in the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::multiset</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="aef7db31d2cf47771a86218a49e8a5948"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_multiset </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::multiset&lt;T, Compare, Allocator&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The comparator to use in the set.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use in the returned container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::multiset</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a1e813962b033f984b9265ebe1cccf6ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::set&lt;T&gt;</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::set</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a0029787ab7a32a1e95cce8f36c04233b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_set </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::set&lt;T, Compare&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The comparator to use in the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::set</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="af476d5605e9d8316ac0c8dcc876188a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_set </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::set&lt;T, Compare, Allocator&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The comparator to use in the set.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use in the returned container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::set</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a90ea8234ca26319428a71b1595d377a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_map&lt;T, std::size_t&gt;</code>. </p>
<p>The map keys are stream elements and each mapped value in the number of occurrences of that key in the stream.</p>

</div>
</div>
<a class="anchor" id="a7e793a030ba73a54fe954ec4429231ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_map </td>
          <td>(</td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_map&lt;T, std::size_t, Hash&gt;</code>. </p>
<p>The map keys are stream elements and each mapped value in the number of occurrences of that key in the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash function to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53348532c7654a7f0164f22f98444e9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash , typename EqualPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_map </td>
          <td>(</td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EqualPredicate&#160;</td>
          <td class="paramname"><em>equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_map&lt;T, std::size_t, Hash, EqualPredicate&gt;</code>. </p>
<p>The map keys are stream elements and each mapped value in the number of occurrences of that key in the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash function to use.</td></tr>
    <tr><td class="paramname">equal</td><td>The function to use for the equality predicate in the hash table.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e9d7306678c5cab545798fa67144fe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash , typename EqualPredicate , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_map </td>
          <td>(</td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EqualPredicate&#160;</td>
          <td class="paramname"><em>equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_map&lt;T, std::size_t, Hash, EqualPredicate, Allocator&gt;</code>. </p>
<p>The map keys are stream elements and each mapped value in the number of occurrences of that key in the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash function to use.</td></tr>
    <tr><td class="paramname">equal</td><td>The function to use for the equality predicate in the hash table.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use in the returned container.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba2326e9fec317a54a1e151a94cde753"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_multiset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_multiset&lt;T&gt;</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::unordered_multiset</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a6cfedb440c13860b072c5731f8ab1d46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_multiset </td>
          <td>(</td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_multiset&lt;T, Hash&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash function to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::unordered_multiset</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="ad3fbd598715bc9ace15baecac72b154f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash , typename EqualPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_multiset </td>
          <td>(</td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EqualPredicate&#160;</td>
          <td class="paramname"><em>equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_multiset&lt;T, Hash, EqualPredicate&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash function to use.</td></tr>
    <tr><td class="paramname">equal</td><td>The function to use for the equality predicate in the hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::unordered_multiset</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="aa4dc941b1b4aeac95b072216a663057e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash , typename EqualPredicate , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_multiset </td>
          <td>(</td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EqualPredicate&#160;</td>
          <td class="paramname"><em>equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_multiset&lt;T, Hash, EqualPredicate, Allocator&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash function to use.</td></tr>
    <tr><td class="paramname">equal</td><td>The function to use for the equality predicate in the hash table.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use in the returned container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::unordered_multiset</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="ab6d5aa7c8fa867dceca1bbca79e2ac1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_set&lt;T&gt;</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::unordered_set</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="ae6bc84b6fa611511105abe67f63ff983"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_set </td>
          <td>(</td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_set&lt;T, Hash&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash function to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::unordered_set</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="af4e4dba597728fea66fd360b4ad69791"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash , typename EqualPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_set </td>
          <td>(</td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EqualPredicate&#160;</td>
          <td class="paramname"><em>equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_set&lt;T, Hash, EqualPredicate&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash function to use.</td></tr>
    <tr><td class="paramname">equal</td><td>The function to use for the equality predicate in the hash table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::unordered_set</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a969446e33e7a16cfcbf417c42eaab3ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash , typename EqualPredicate , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_unordered_set </td>
          <td>(</td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EqualPredicate&#160;</td>
          <td class="paramname"><em>equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::unordered_set&lt;T, Hash, EqualPredicate, Allocator&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash function to use.</td></tr>
    <tr><td class="paramname">equal</td><td>The function to use for the equality predicate in the hash table.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use in the returned container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::unordered_set</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="ae65b798b18b47576c1ffed6f63814fc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::vector&lt;T&gt;</code> in order. </p>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::vector</code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a67f68b3569f0a73e2bbc6e42d83bbe85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::terminal::to_vector </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the stream into a <code>std::vector&lt;T, Allocator&gt;</code> in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The allocator to use in the returned container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A terminal operation which copies the stream into a <code>std::vector</code>.</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
