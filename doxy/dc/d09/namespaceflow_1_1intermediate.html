<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Flow: flow::intermediate Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Flow
   </div>
   <div id="projectbrief">Lazy Evaluated Stream Processing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/de2/namespaceflow.html">flow</a></li><li class="navelem"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html">intermediate</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">flow::intermediate Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Intermediate operations, all of which are also aliased in the flow namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa0551274cc05f2c668d5612bfe1716cb"><td class="memTemplParams" colspan="2">template&lt;typename Tail &gt; </td></tr>
<tr class="memitem:aa0551274cc05f2c668d5612bfe1716cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa0551274cc05f2c668d5612bfe1716cb">concat</a> (<a class="el" href="../../d9/dcd/classflow_1_1_stream.html">Stream</a>&lt; Tail &gt; &amp;&amp;tail)</td></tr>
<tr class="memdesc:aa0551274cc05f2c668d5612bfe1716cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the <em>tail</em>  stream onto the end of the operated (<em>head</em> ) stream.  <a href="#aa0551274cc05f2c668d5612bfe1716cb">More...</a><br /></td></tr>
<tr class="separator:aa0551274cc05f2c668d5612bfe1716cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac535fea33e2424506d0bbf56409f99a7"><td class="memTemplParams" colspan="2">template&lt;typename Itr &gt; </td></tr>
<tr class="memitem:ac535fea33e2424506d0bbf56409f99a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac535fea33e2424506d0bbf56409f99a7">concat</a> (Itr begin, Itr end)</td></tr>
<tr class="memdesc:ac535fea33e2424506d0bbf56409f99a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the given iterator range onto the end of the stream, this is the same as <code>concat(from(begin, end))</code>.  <a href="#ac535fea33e2424506d0bbf56409f99a7">More...</a><br /></td></tr>
<tr class="separator:ac535fea33e2424506d0bbf56409f99a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955cba2286efa38c29c17ee9d2fd43f5"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a955cba2286efa38c29c17ee9d2fd43f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a955cba2286efa38c29c17ee9d2fd43f5">concat</a> (Container &amp;container)</td></tr>
<tr class="memdesc:a955cba2286efa38c29c17ee9d2fd43f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates <em>container</em>  onto the end of the stream, this is the same as <code>concat(from(container))</code>.  <a href="#a955cba2286efa38c29c17ee9d2fd43f5">More...</a><br /></td></tr>
<tr class="separator:a955cba2286efa38c29c17ee9d2fd43f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b48f9084349825be7f428ee4b7883d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29b48f9084349825be7f428ee4b7883d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a29b48f9084349825be7f428ee4b7883d">concat</a> (std::initializer_list&lt; T &gt; list)</td></tr>
<tr class="memdesc:a29b48f9084349825be7f428ee4b7883d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates <em>list</em>  onto the end of the stream, this is the same as <code>concat(from(list))</code>.  <a href="#a29b48f9084349825be7f428ee4b7883d">More...</a><br /></td></tr>
<tr class="separator:a29b48f9084349825be7f428ee4b7883d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6e57bccb66cfbfae54134b500ea8c0"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a1c6e57bccb66cfbfae54134b500ea8c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a1c6e57bccb66cfbfae54134b500ea8c0">drop_while</a> (UnaryPredicate predicate)</td></tr>
<tr class="memdesc:a1c6e57bccb66cfbfae54134b500ea8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops elements from the stream until the <em>predicate</em>  returns <code>false</code> for a stream element.  <a href="#a1c6e57bccb66cfbfae54134b500ea8c0">More...</a><br /></td></tr>
<tr class="separator:a1c6e57bccb66cfbfae54134b500ea8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af375a0d8fadc8ec0e0d2b97a1d2907a5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af375a0d8fadc8ec0e0d2b97a1d2907a5">drop_while</a> ()</td></tr>
<tr class="memdesc:af375a0d8fadc8ec0e0d2b97a1d2907a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops elements from the stream until a stream element is <code>false</code>.  <a href="#af375a0d8fadc8ec0e0d2b97a1d2907a5">More...</a><br /></td></tr>
<tr class="separator:af375a0d8fadc8ec0e0d2b97a1d2907a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680ea915183bfa1bd72ff0a342a6bb1f"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:a680ea915183bfa1bd72ff0a342a6bb1f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a680ea915183bfa1bd72ff0a342a6bb1f">drop_while</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:a680ea915183bfa1bd72ff0a342a6bb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops elements from the stream until the <em>member</em>  returns <code>false</code>.  <a href="#a680ea915183bfa1bd72ff0a342a6bb1f">More...</a><br /></td></tr>
<tr class="separator:a680ea915183bfa1bd72ff0a342a6bb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74be97ab2dbd180f7d1127a88cfcf8c"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aa74be97ab2dbd180f7d1127a88cfcf8c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c">filter</a> (UnaryPredicate predicate)</td></tr>
<tr class="memdesc:aa74be97ab2dbd180f7d1127a88cfcf8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes elements from the stream that return <code>false</code> for <em>predicate</em> .  <a href="#aa74be97ab2dbd180f7d1127a88cfcf8c">More...</a><br /></td></tr>
<tr class="separator:aa74be97ab2dbd180f7d1127a88cfcf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99debd4465f5e92791995d9a985a0a2d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a99debd4465f5e92791995d9a985a0a2d">filter</a> ()</td></tr>
<tr class="memdesc:a99debd4465f5e92791995d9a985a0a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes elements from the stream which are evaluated to <code>false</code>.  <a href="#a99debd4465f5e92791995d9a985a0a2d">More...</a><br /></td></tr>
<tr class="separator:a99debd4465f5e92791995d9a985a0a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1f3921d4f70c95c8e576ec40f8cdd2"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:a6e1f3921d4f70c95c8e576ec40f8cdd2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a6e1f3921d4f70c95c8e576ec40f8cdd2">filter</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:a6e1f3921d4f70c95c8e576ec40f8cdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes elements from the stream that return <code>false</code> for <em>member</em> .  <a href="#a6e1f3921d4f70c95c8e576ec40f8cdd2">More...</a><br /></td></tr>
<tr class="separator:a6e1f3921d4f70c95c8e576ec40f8cdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5917010c6f56abf7ba421dbe0f5e92b"><td class="memTemplParams" colspan="2">template&lt;typename UnaryOperation &gt; </td></tr>
<tr class="memitem:ae5917010c6f56abf7ba421dbe0f5e92b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ae5917010c6f56abf7ba421dbe0f5e92b">flat_map</a> (UnaryOperation operation)</td></tr>
<tr class="memdesc:ae5917010c6f56abf7ba421dbe0f5e92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms each element in the stream using <em>operation</em>  into a new stream.  <a href="#ae5917010c6f56abf7ba421dbe0f5e92b">More...</a><br /></td></tr>
<tr class="separator:ae5917010c6f56abf7ba421dbe0f5e92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347e52317b201a9e142031724ea4de0a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a347e52317b201a9e142031724ea4de0a">limit</a> (std::size_t length)</td></tr>
<tr class="memdesc:a347e52317b201a9e142031724ea4de0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limits the length of the stream to <em>length</em>  elements.  <a href="#a347e52317b201a9e142031724ea4de0a">More...</a><br /></td></tr>
<tr class="separator:a347e52317b201a9e142031724ea4de0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af704cfd8b681a9cd8b2437d249487f78"><td class="memTemplParams" colspan="2">template&lt;typename UnaryOperation &gt; </td></tr>
<tr class="memitem:af704cfd8b681a9cd8b2437d249487f78"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78">map</a> (UnaryOperation mapper)</td></tr>
<tr class="memdesc:af704cfd8b681a9cd8b2437d249487f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms each element in the stream using <em>mapper</em> .  <a href="#af704cfd8b681a9cd8b2437d249487f78">More...</a><br /></td></tr>
<tr class="separator:af704cfd8b681a9cd8b2437d249487f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7bef0ac778a95140e38bb9e81ae83a"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:aae7bef0ac778a95140e38bb9e81ae83a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aae7bef0ac778a95140e38bb9e81ae83a">map</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:aae7bef0ac778a95140e38bb9e81ae83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms each element in the stream to the return value of <em>member</em>  for each stream element.  <a href="#aae7bef0ac778a95140e38bb9e81ae83a">More...</a><br /></td></tr>
<tr class="separator:aae7bef0ac778a95140e38bb9e81ae83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb2b65333a532367af81f9ff82149f4"><td class="memTemplParams" colspan="2">template&lt;typename RightSource , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a6fb2b65333a532367af81f9ff82149f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a6fb2b65333a532367af81f9ff82149f4">merge</a> (<a class="el" href="../../d9/dcd/classflow_1_1_stream.html">Stream</a>&lt; RightSource &gt; &amp;&amp;right, Compare compare=Compare())</td></tr>
<tr class="memdesc:a6fb2b65333a532367af81f9ff82149f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the <em>right</em>  stream into the operated (<em>left</em> ) stream while maintaining sorted order.  <a href="#a6fb2b65333a532367af81f9ff82149f4">More...</a><br /></td></tr>
<tr class="separator:a6fb2b65333a532367af81f9ff82149f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdce04079f1718a815a7e46718b1c432"><td class="memTemplParams" colspan="2">template&lt;typename Itr , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:acdce04079f1718a815a7e46718b1c432"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#acdce04079f1718a815a7e46718b1c432">merge</a> (Itr begin, Itr end, Compare compare=Compare())</td></tr>
<tr class="memdesc:acdce04079f1718a815a7e46718b1c432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the iterator range into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>merge(from(begin, end), compare)</code>.  <a href="#acdce04079f1718a815a7e46718b1c432">More...</a><br /></td></tr>
<tr class="separator:acdce04079f1718a815a7e46718b1c432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacae60f668337190c275857590b158c"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare  = std::less&lt;void&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:afacae60f668337190c275857590b158c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#afacae60f668337190c275857590b158c">merge</a> (Container &amp;container, Compare compare=Compare())</td></tr>
<tr class="memdesc:afacae60f668337190c275857590b158c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges <em>container</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>merge(from(container), compare)</code>.  <a href="#afacae60f668337190c275857590b158c">More...</a><br /></td></tr>
<tr class="separator:afacae60f668337190c275857590b158c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857d36211d87bff95b2e41425933e8ec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a857d36211d87bff95b2e41425933e8ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a857d36211d87bff95b2e41425933e8ec">merge</a> (std::initializer_list&lt; T &gt; list, Compare compare=Compare())</td></tr>
<tr class="memdesc:a857d36211d87bff95b2e41425933e8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges <em>list</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>merge(from(list), compare)</code>.  <a href="#a857d36211d87bff95b2e41425933e8ec">More...</a><br /></td></tr>
<tr class="separator:a857d36211d87bff95b2e41425933e8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9078ec57972888d23411f8c3ea209af"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:ac9078ec57972888d23411f8c3ea209af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac9078ec57972888d23411f8c3ea209af">peek</a> (UnaryFunction action)</td></tr>
<tr class="memdesc:ac9078ec57972888d23411f8c3ea209af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes <em>action</em>  for each element in the stream.  <a href="#ac9078ec57972888d23411f8c3ea209af">More...</a><br /></td></tr>
<tr class="separator:ac9078ec57972888d23411f8c3ea209af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32b7bf1f105167d576b779b3b5f0297"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:af32b7bf1f105167d576b779b3b5f0297"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af32b7bf1f105167d576b779b3b5f0297">peek</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:af32b7bf1f105167d576b779b3b5f0297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes <em>member</em>  for each element in the stream.  <a href="#af32b7bf1f105167d576b779b3b5f0297">More...</a><br /></td></tr>
<tr class="separator:af32b7bf1f105167d576b779b3b5f0297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11854b160914181e130029b111facf55"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate , typename T &gt; </td></tr>
<tr class="memitem:a11854b160914181e130029b111facf55"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a11854b160914181e130029b111facf55">replace</a> (UnaryPredicate predicate, T &amp;&amp;replace_by)</td></tr>
<tr class="memdesc:a11854b160914181e130029b111facf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces elements in the stream by <em>replace_by</em>  if the stream element returns <code>true</code> for <em>predicate</em> .  <a href="#a11854b160914181e130029b111facf55">More...</a><br /></td></tr>
<tr class="separator:a11854b160914181e130029b111facf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25fa6ade81d666f3e4f85f5ad5502047"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25fa6ade81d666f3e4f85f5ad5502047"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a25fa6ade81d666f3e4f85f5ad5502047">replace</a> (T &amp;&amp;old_value, T &amp;&amp;new_value)</td></tr>
<tr class="memdesc:a25fa6ade81d666f3e4f85f5ad5502047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces elements in the stream by <em>new_value</em>  if they are equal to <em>old_value</em> .  <a href="#a25fa6ade81d666f3e4f85f5ad5502047">More...</a><br /></td></tr>
<tr class="separator:a25fa6ade81d666f3e4f85f5ad5502047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db61e00aa587124edb99e065385ef16"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:a0db61e00aa587124edb99e065385ef16"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a0db61e00aa587124edb99e065385ef16">replace_map</a> (UnaryPredicate predicate, UnaryOperation mapper)</td></tr>
<tr class="memdesc:a0db61e00aa587124edb99e065385ef16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps stream elements to new values if the original element returns <code>true</code> for <em>predicate</em> .  <a href="#a0db61e00aa587124edb99e065385ef16">More...</a><br /></td></tr>
<tr class="separator:a0db61e00aa587124edb99e065385ef16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13397178496f74369fc8dae063415b7a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a13397178496f74369fc8dae063415b7a">reverse</a> ()</td></tr>
<tr class="memdesc:a13397178496f74369fc8dae063415b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the elements in the stream.  <a href="#a13397178496f74369fc8dae063415b7a">More...</a><br /></td></tr>
<tr class="separator:a13397178496f74369fc8dae063415b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad934301c4575e60e7fa4f8acac75e471"><td class="memTemplParams" colspan="2">template&lt;typename RightSource , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:ad934301c4575e60e7fa4f8acac75e471"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ad934301c4575e60e7fa4f8acac75e471">set_diff</a> (<a class="el" href="../../d9/dcd/classflow_1_1_stream.html">Stream</a>&lt; RightSource &gt; &amp;&amp;right, Compare compare=Compare())</td></tr>
<tr class="memdesc:ad934301c4575e60e7fa4f8acac75e471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference of the operated (<em>left</em> ) stream and the <em>right</em>  stream while maintaining sorted order.  <a href="#ad934301c4575e60e7fa4f8acac75e471">More...</a><br /></td></tr>
<tr class="separator:ad934301c4575e60e7fa4f8acac75e471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e3e38fbff02cb68a8d88ee83f1ed10"><td class="memTemplParams" colspan="2">template&lt;typename Itr , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:ab6e3e38fbff02cb68a8d88ee83f1ed10"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ab6e3e38fbff02cb68a8d88ee83f1ed10">set_diff</a> (Itr begin, Itr end, Compare compare=Compare())</td></tr>
<tr class="memdesc:ab6e3e38fbff02cb68a8d88ee83f1ed10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference of the operated (<em>left</em> ) stream and the iterator range while maintaining sorted order, this is the same as <code>set_diff(from(begin, end), compare)</code>.  <a href="#ab6e3e38fbff02cb68a8d88ee83f1ed10">More...</a><br /></td></tr>
<tr class="separator:ab6e3e38fbff02cb68a8d88ee83f1ed10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56200dc064f3c59c0fce20242ae80e4a"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare  = std::less&lt;void&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a56200dc064f3c59c0fce20242ae80e4a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a56200dc064f3c59c0fce20242ae80e4a">set_diff</a> (Container &amp;container, Compare compare=Compare())</td></tr>
<tr class="memdesc:a56200dc064f3c59c0fce20242ae80e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference of the operated (<em>left</em> ) stream and <em>container</em>  while maintaining sorted order, this is the same as <code>set_diff(from(container), compare)</code>.  <a href="#a56200dc064f3c59c0fce20242ae80e4a">More...</a><br /></td></tr>
<tr class="separator:a56200dc064f3c59c0fce20242ae80e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea643c657fff06efd5a4d7c07fc1659b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:aea643c657fff06efd5a4d7c07fc1659b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aea643c657fff06efd5a4d7c07fc1659b">set_diff</a> (std::initializer_list&lt; T &gt; list, Compare compare=Compare())</td></tr>
<tr class="memdesc:aea643c657fff06efd5a4d7c07fc1659b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference of the operated (<em>left</em> ) stream and <em>list</em>  while maintaining sorted order, this is the same as <code>set_diff(from(list), compare)</code>.  <a href="#aea643c657fff06efd5a4d7c07fc1659b">More...</a><br /></td></tr>
<tr class="separator:aea643c657fff06efd5a4d7c07fc1659b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414b603609b514656419e512f8b8d8c2"><td class="memTemplParams" colspan="2">template&lt;typename RightSource , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a414b603609b514656419e512f8b8d8c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a414b603609b514656419e512f8b8d8c2">set_intersect</a> (<a class="el" href="../../d9/dcd/classflow_1_1_stream.html">Stream</a>&lt; RightSource &gt; &amp;&amp;right, Compare compare=Compare())</td></tr>
<tr class="memdesc:a414b603609b514656419e512f8b8d8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the <em>right</em>  stream into the operated (<em>left</em> ) stream while maintaining sorted order.  <a href="#a414b603609b514656419e512f8b8d8c2">More...</a><br /></td></tr>
<tr class="separator:a414b603609b514656419e512f8b8d8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ce01f16c8bd1911ed6735ab6876507"><td class="memTemplParams" colspan="2">template&lt;typename Itr , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a27ce01f16c8bd1911ed6735ab6876507"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a27ce01f16c8bd1911ed6735ab6876507">set_intersect</a> (Itr begin, Itr end, Compare compare=Compare())</td></tr>
<tr class="memdesc:a27ce01f16c8bd1911ed6735ab6876507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the iterator range into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_intersect(from(begin, end), compare)</code>.  <a href="#a27ce01f16c8bd1911ed6735ab6876507">More...</a><br /></td></tr>
<tr class="separator:a27ce01f16c8bd1911ed6735ab6876507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c367fd8127d79dc9b73068cb6f41a6f"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare  = std::less&lt;void&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a9c367fd8127d79dc9b73068cb6f41a6f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a9c367fd8127d79dc9b73068cb6f41a6f">set_intersect</a> (Container &amp;container, Compare compare=Compare())</td></tr>
<tr class="memdesc:a9c367fd8127d79dc9b73068cb6f41a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects <em>container</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_intersect(from(container), compare)</code>.  <a href="#a9c367fd8127d79dc9b73068cb6f41a6f">More...</a><br /></td></tr>
<tr class="separator:a9c367fd8127d79dc9b73068cb6f41a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77ba087a55f3703d2d812f8da9655ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:ad77ba087a55f3703d2d812f8da9655ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ad77ba087a55f3703d2d812f8da9655ad">set_intersect</a> (std::initializer_list&lt; T &gt; list, Compare compare=Compare())</td></tr>
<tr class="memdesc:ad77ba087a55f3703d2d812f8da9655ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects <em>list</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_intersect(from(list), compare)</code>.  <a href="#ad77ba087a55f3703d2d812f8da9655ad">More...</a><br /></td></tr>
<tr class="separator:ad77ba087a55f3703d2d812f8da9655ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bf95f0e80dcb00c805775a0b799adf"><td class="memTemplParams" colspan="2">template&lt;typename RightSource , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a16bf95f0e80dcb00c805775a0b799adf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a16bf95f0e80dcb00c805775a0b799adf">set_sym_diff</a> (<a class="el" href="../../d9/dcd/classflow_1_1_stream.html">Stream</a>&lt; RightSource &gt; &amp;&amp;right, Compare compare=Compare())</td></tr>
<tr class="memdesc:a16bf95f0e80dcb00c805775a0b799adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the symmetric difference of the operated (<em>left</em> ) stream and the <em>right</em>  stream while maintaining sorted order.  <a href="#a16bf95f0e80dcb00c805775a0b799adf">More...</a><br /></td></tr>
<tr class="separator:a16bf95f0e80dcb00c805775a0b799adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f01de329bfbe82b66fecc70d6fb338b"><td class="memTemplParams" colspan="2">template&lt;typename Itr , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a5f01de329bfbe82b66fecc70d6fb338b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a5f01de329bfbe82b66fecc70d6fb338b">set_sym_diff</a> (Itr begin, Itr end, Compare compare=Compare())</td></tr>
<tr class="memdesc:a5f01de329bfbe82b66fecc70d6fb338b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the symmetric difference of the operated (<em>left</em> ) stream and the iterator range while maintaining sorted order, this is the same as <code>set_sym_diff(from(begin, end), compare)</code>.  <a href="#a5f01de329bfbe82b66fecc70d6fb338b">More...</a><br /></td></tr>
<tr class="separator:a5f01de329bfbe82b66fecc70d6fb338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be578ea731acfba3a2473b5a44e98e2"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare  = std::less&lt;void&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a1be578ea731acfba3a2473b5a44e98e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a1be578ea731acfba3a2473b5a44e98e2">set_sym_diff</a> (Container &amp;container, Compare compare=Compare())</td></tr>
<tr class="memdesc:a1be578ea731acfba3a2473b5a44e98e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the symmetric difference of the operated (<em>left</em> ) stream and <em>container</em>  while maintaining sorted order, this is the same as <code>set_sym_diff(from(container), compare)</code>.  <a href="#a1be578ea731acfba3a2473b5a44e98e2">More...</a><br /></td></tr>
<tr class="separator:a1be578ea731acfba3a2473b5a44e98e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcafd1b53147e51a9af8fab6e35dc5b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a6fcafd1b53147e51a9af8fab6e35dc5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a6fcafd1b53147e51a9af8fab6e35dc5b">set_sym_diff</a> (std::initializer_list&lt; T &gt; list, Compare compare=Compare())</td></tr>
<tr class="memdesc:a6fcafd1b53147e51a9af8fab6e35dc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the symmetric difference of the operated (<em>left</em> ) stream and <em>list</em>  while maintaining sorted order, this is the same as <code>set_sym_diff(from(list), compare)</code>.  <a href="#a6fcafd1b53147e51a9af8fab6e35dc5b">More...</a><br /></td></tr>
<tr class="separator:a6fcafd1b53147e51a9af8fab6e35dc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497f972f0f5add67935c3bb47a44d104"><td class="memTemplParams" colspan="2">template&lt;typename RightSource , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a497f972f0f5add67935c3bb47a44d104"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a497f972f0f5add67935c3bb47a44d104">set_union</a> (<a class="el" href="../../d9/dcd/classflow_1_1_stream.html">Stream</a>&lt; RightSource &gt; &amp;&amp;right, Compare compare=Compare())</td></tr>
<tr class="memdesc:a497f972f0f5add67935c3bb47a44d104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unions the <em>right</em>  stream into the operated (<em>left</em> ) stream while maintaining sorted order.  <a href="#a497f972f0f5add67935c3bb47a44d104">More...</a><br /></td></tr>
<tr class="separator:a497f972f0f5add67935c3bb47a44d104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7938e2d876a879ee6edf0e2e31ffec8"><td class="memTemplParams" colspan="2">template&lt;typename Itr , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:aa7938e2d876a879ee6edf0e2e31ffec8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa7938e2d876a879ee6edf0e2e31ffec8">set_union</a> (Itr begin, Itr end, Compare compare=Compare())</td></tr>
<tr class="memdesc:aa7938e2d876a879ee6edf0e2e31ffec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unions the iterator range into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_union(from(begin, end), compare)</code>.  <a href="#aa7938e2d876a879ee6edf0e2e31ffec8">More...</a><br /></td></tr>
<tr class="separator:aa7938e2d876a879ee6edf0e2e31ffec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41227f6665b9a8fcdb8b066ea3226028"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare  = std::less&lt;void&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a41227f6665b9a8fcdb8b066ea3226028"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a41227f6665b9a8fcdb8b066ea3226028">set_union</a> (Container &amp;container, Compare compare=Compare())</td></tr>
<tr class="memdesc:a41227f6665b9a8fcdb8b066ea3226028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unions <em>container</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_union(from(container), compare)</code>.  <a href="#a41227f6665b9a8fcdb8b066ea3226028">More...</a><br /></td></tr>
<tr class="separator:a41227f6665b9a8fcdb8b066ea3226028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac490fe88e884eed9befb822cedbef139"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:ac490fe88e884eed9befb822cedbef139"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac490fe88e884eed9befb822cedbef139">set_union</a> (std::initializer_list&lt; T &gt; list, Compare compare=Compare())</td></tr>
<tr class="memdesc:ac490fe88e884eed9befb822cedbef139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unions <em>list</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_union(from(list), compare)</code>.  <a href="#ac490fe88e884eed9befb822cedbef139">More...</a><br /></td></tr>
<tr class="separator:ac490fe88e884eed9befb822cedbef139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2725d9fb49cd0c4fe25658500c2fa1f1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a2725d9fb49cd0c4fe25658500c2fa1f1">skip</a> (std::size_t begin, std::size_t step_size)</td></tr>
<tr class="memdesc:a2725d9fb49cd0c4fe25658500c2fa1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips the first elements of a stream, keeping only the elements with index <code>&gt;=</code> <em>begin</em>  in the stream.  <a href="#a2725d9fb49cd0c4fe25658500c2fa1f1">More...</a><br /></td></tr>
<tr class="separator:a2725d9fb49cd0c4fe25658500c2fa1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8b2e7e5cc41ecd02cb4381a706d545"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a2f8b2e7e5cc41ecd02cb4381a706d545">skip</a> (std::size_t begin)</td></tr>
<tr class="memdesc:a2f8b2e7e5cc41ecd02cb4381a706d545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips the first elements of a stream, keeping only the elements with index <code>&gt;=</code> <em>begin</em>  in the stream.  <a href="#a2f8b2e7e5cc41ecd02cb4381a706d545">More...</a><br /></td></tr>
<tr class="separator:a2f8b2e7e5cc41ecd02cb4381a706d545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef64fd0f533b9b084b83c46fe8352d4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aeef64fd0f533b9b084b83c46fe8352d4">skip_every</a> (std::size_t step_size)</td></tr>
<tr class="memdesc:aeef64fd0f533b9b084b83c46fe8352d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips every <em>step_size</em>  elements in the stream, keeping the first element.  <a href="#aeef64fd0f533b9b084b83c46fe8352d4">More...</a><br /></td></tr>
<tr class="separator:aeef64fd0f533b9b084b83c46fe8352d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1954e2f5425b7603794790f7645e776e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a1954e2f5425b7603794790f7645e776e">slice</a> (std::size_t begin, std::size_t end, std::size_t step_size)</td></tr>
<tr class="memdesc:a1954e2f5425b7603794790f7645e776e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices the stream, keeping only elements with index in the range <code>[begin..end)</code> in the stream, excluding the <em>end</em>  index.  <a href="#a1954e2f5425b7603794790f7645e776e">More...</a><br /></td></tr>
<tr class="separator:a1954e2f5425b7603794790f7645e776e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8468b308d2903331dc966819b373625"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac8468b308d2903331dc966819b373625">slice</a> (std::size_t begin, std::size_t end)</td></tr>
<tr class="memdesc:ac8468b308d2903331dc966819b373625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices the stream, keeping only elements with index in the range <code>[begin..end)</code> in the stream, excluding the <em>end</em>  index.  <a href="#ac8468b308d2903331dc966819b373625">More...</a><br /></td></tr>
<tr class="separator:ac8468b308d2903331dc966819b373625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0641d6ecc741bd5f346a961e5e8ccf44"><td class="memTemplParams" colspan="2">template&lt;typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a0641d6ecc741bd5f346a961e5e8ccf44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a0641d6ecc741bd5f346a961e5e8ccf44">sort</a> (Compare compare=Compare())</td></tr>
<tr class="memdesc:a0641d6ecc741bd5f346a961e5e8ccf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the stream using the given comparator, <code>operator&lt;</code> by default.  <a href="#a0641d6ecc741bd5f346a961e5e8ccf44">More...</a><br /></td></tr>
<tr class="separator:a0641d6ecc741bd5f346a961e5e8ccf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a5f0773de4aac232e80ae23495e76e"><td class="memTemplParams" colspan="2">template&lt;typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:ab9a5f0773de4aac232e80ae23495e76e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ab9a5f0773de4aac232e80ae23495e76e">stable_sort</a> (Compare compare=Compare())</td></tr>
<tr class="memdesc:ab9a5f0773de4aac232e80ae23495e76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the stream preserving relative order of elements using the given comparator, <code>operator&lt;</code> by default.  <a href="#ab9a5f0773de4aac232e80ae23495e76e">More...</a><br /></td></tr>
<tr class="separator:ab9a5f0773de4aac232e80ae23495e76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af694d1a9aa88f1dd8ff3d3e66d2cb6c9"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:af694d1a9aa88f1dd8ff3d3e66d2cb6c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af694d1a9aa88f1dd8ff3d3e66d2cb6c9">take_while</a> (UnaryPredicate predicate)</td></tr>
<tr class="memdesc:af694d1a9aa88f1dd8ff3d3e66d2cb6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes elements from the stream until <em>predicate</em>  returns <code>false</code> for an element.  <a href="#af694d1a9aa88f1dd8ff3d3e66d2cb6c9">More...</a><br /></td></tr>
<tr class="separator:af694d1a9aa88f1dd8ff3d3e66d2cb6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213755b414a7d31af11bb96c129c6667"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a213755b414a7d31af11bb96c129c6667">take_while</a> ()</td></tr>
<tr class="memdesc:a213755b414a7d31af11bb96c129c6667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes elements from the stream until an element is <code>false</code>.  <a href="#a213755b414a7d31af11bb96c129c6667">More...</a><br /></td></tr>
<tr class="separator:a213755b414a7d31af11bb96c129c6667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3882ef78e687785e2c1402e4a62ea1"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Class &gt; </td></tr>
<tr class="memitem:adf3882ef78e687785e2c1402e4a62ea1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#adf3882ef78e687785e2c1402e4a62ea1">take_while</a> (Ret(Class::*member)())</td></tr>
<tr class="memdesc:adf3882ef78e687785e2c1402e4a62ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes elements from the stream until the <em>member</em>  returns <code>false</code>.  <a href="#adf3882ef78e687785e2c1402e4a62ea1">More...</a><br /></td></tr>
<tr class="separator:adf3882ef78e687785e2c1402e4a62ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304866b3dec4eafe95a024319328ef2c"><td class="memTemplParams" colspan="2">template&lt;typename Compare  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a304866b3dec4eafe95a024319328ef2c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a304866b3dec4eafe95a024319328ef2c">unique</a> (Compare compare=Compare())</td></tr>
<tr class="memdesc:a304866b3dec4eafe95a024319328ef2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts and extracts only unique elements from the stream.  <a href="#a304866b3dec4eafe95a024319328ef2c">More...</a><br /></td></tr>
<tr class="separator:a304866b3dec4eafe95a024319328ef2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25b0a8475258acc29173c4a37e13e22"><td class="memTemplParams" colspan="2">template&lt;typename RightSource , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:ae25b0a8475258acc29173c4a37e13e22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ae25b0a8475258acc29173c4a37e13e22">zip</a> (<a class="el" href="../../d9/dcd/classflow_1_1_stream.html">Stream</a>&lt; RightSource &gt; &amp;&amp;right, BinaryOperation zipper)</td></tr>
<tr class="memdesc:ae25b0a8475258acc29173c4a37e13e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips the two streams together using <em>zipper</em>  as the zipping operation.  <a href="#ae25b0a8475258acc29173c4a37e13e22">More...</a><br /></td></tr>
<tr class="separator:ae25b0a8475258acc29173c4a37e13e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb00402c75a7be66d0d82652d275889d"><td class="memTemplParams" colspan="2">template&lt;typename Itr , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:afb00402c75a7be66d0d82652d275889d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#afb00402c75a7be66d0d82652d275889d">zip</a> (Itr begin, Itr end, BinaryOperation zipper)</td></tr>
<tr class="memdesc:afb00402c75a7be66d0d82652d275889d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips the two streams together using <em>zipper</em>  as the zipping operation, this is the same as <code>zip(from(begin, end), zipper)</code>.  <a href="#afb00402c75a7be66d0d82652d275889d">More...</a><br /></td></tr>
<tr class="separator:afb00402c75a7be66d0d82652d275889d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573b95c3fc149372b6659127f7d47814"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename BinaryOperation , typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a573b95c3fc149372b6659127f7d47814"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a573b95c3fc149372b6659127f7d47814">zip</a> (Container &amp;container, BinaryOperation zipper)</td></tr>
<tr class="memdesc:a573b95c3fc149372b6659127f7d47814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips the two streams together using <em>zipper</em>  as the zipping operation, this is the same as <code>zip(from(container), zipper)</code>.  <a href="#a573b95c3fc149372b6659127f7d47814">More...</a><br /></td></tr>
<tr class="separator:a573b95c3fc149372b6659127f7d47814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7916efdf915b8224595dd84557f20874"><td class="memTemplParams" colspan="2">template&lt;typename T , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a7916efdf915b8224595dd84557f20874"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a7916efdf915b8224595dd84557f20874">zip</a> (std::initializer_list&lt; T &gt; list, BinaryOperation zipper)</td></tr>
<tr class="memdesc:a7916efdf915b8224595dd84557f20874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips the two streams together using <em>zipper</em>  as the zipping operation, this is the same as <code>zip(from(list), zipper)</code>.  <a href="#a7916efdf915b8224595dd84557f20874">More...</a><br /></td></tr>
<tr class="separator:a7916efdf915b8224595dd84557f20874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1ec0323daa06ef6b093f1d0aa4c1cc"><td class="memTemplParams" colspan="2">template&lt;typename RightSource &gt; </td></tr>
<tr class="memitem:a7f1ec0323daa06ef6b093f1d0aa4c1cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a7f1ec0323daa06ef6b093f1d0aa4c1cc">zip</a> (<a class="el" href="../../d9/dcd/classflow_1_1_stream.html">Stream</a>&lt; RightSource &gt; &amp;&amp;right)</td></tr>
<tr class="memdesc:a7f1ec0323daa06ef6b093f1d0aa4c1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips the two streams together using the default zipping operation.  <a href="#a7f1ec0323daa06ef6b093f1d0aa4c1cc">More...</a><br /></td></tr>
<tr class="separator:a7f1ec0323daa06ef6b093f1d0aa4c1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07acbb7524420dd6b7b05f609212395"><td class="memTemplParams" colspan="2">template&lt;typename Itr &gt; </td></tr>
<tr class="memitem:af07acbb7524420dd6b7b05f609212395"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af07acbb7524420dd6b7b05f609212395">zip</a> (Itr begin, Itr end)</td></tr>
<tr class="memdesc:af07acbb7524420dd6b7b05f609212395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips the two streams together using the default zipping operation, this is the same as <code>zip(from(begin, end))</code>.  <a href="#af07acbb7524420dd6b7b05f609212395">More...</a><br /></td></tr>
<tr class="separator:af07acbb7524420dd6b7b05f609212395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fc82a612a709360fac445a46001509"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ab2fc82a612a709360fac445a46001509"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ab2fc82a612a709360fac445a46001509">zip</a> (Container &amp;container)</td></tr>
<tr class="memdesc:ab2fc82a612a709360fac445a46001509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips the two streams together using the default zipping operation, this is the same as <code>zip(from(container))</code>.  <a href="#ab2fc82a612a709360fac445a46001509">More...</a><br /></td></tr>
<tr class="separator:ab2fc82a612a709360fac445a46001509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b531057c1a25cd2488f1f6817c0d63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5b531057c1a25cd2488f1f6817c0d63"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ab5b531057c1a25cd2488f1f6817c0d63">zip</a> (std::initializer_list&lt; T &gt; list)</td></tr>
<tr class="memdesc:ab5b531057c1a25cd2488f1f6817c0d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips the two streams together using the default zipping operation, this is the same as <code>zip(from(list))</code>.  <a href="#ab5b531057c1a25cd2488f1f6817c0d63">More...</a><br /></td></tr>
<tr class="separator:ab5b531057c1a25cd2488f1f6817c0d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Intermediate operations, all of which are also aliased in the flow namespace. </p>
<p>The functions in the <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html" title="Intermediate operations, all of which are also aliased in the flow namespace. ">flow::intermediate</a> namespace all produce an intermediate operation. The intermediate operation does not operate on a stream until the pipe <code>operator|</code> has been applied, including eager operations. Only after being applied to a stream is the new stream created.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000003">Todo:</a></b></dt><dd><p class="startdd">group the stream, [1,2,3,4] with group&lt;2&gt; -&gt; [(1,2), (3,4)] </p>
<p>moving window into the stream, [1,2,3] with window&lt;2&gt; -&gt; [(1,2), (2,3)] </p>
<p>adjacent_diff - from &lt;numeric&gt; </p>
<p>partial_sum - from &lt;numeric&gt; </p>
<p>inner_product - from &lt;numeric&gt; </p>
<p>overload arithmetic operators as map operations? </p>
<p class="enddd">shuffle - would have to be eager, take rng as parameter </p>
</dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa0551274cc05f2c668d5612bfe1716cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tail &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::concat </td>
          <td>(</td>
          <td class="paramtype">Stream&lt; Tail &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>tail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the <em>tail</em>  stream onto the end of the operated (<em>head</em> ) stream. </p>
<p>The <em>tail</em>  stream elements must be convertible to the same type of elements as the <em>head</em>  stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tail</td><td>The tail stream to put after the end of the operated head stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that concatenates the two streams.</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d7/db4/concat_8cpp-example.html#a0">concat.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac535fea33e2424506d0bbf56409f99a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Itr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::concat </td>
          <td>(</td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the given iterator range onto the end of the stream, this is the same as <code>concat(from(begin, end))</code>. </p>
<p>The <em>tail</em>  stream elements must be convertible to the same type of elements as the <em>head</em>  stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the range to concat.</td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to concat.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that concatenates the container onto the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a955cba2286efa38c29c17ee9d2fd43f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::concat </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates <em>container</em>  onto the end of the stream, this is the same as <code>concat(from(container))</code>. </p>
<p>The <em>tail</em>  stream elements must be convertible to the same type of elements as the <em>head</em>  stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to concatenate onto the end of the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that concatenates the container onto the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a29b48f9084349825be7f428ee4b7883d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::concat </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates <em>list</em>  onto the end of the stream, this is the same as <code>concat(from(list))</code>. </p>
<p>The <em>tail</em>  stream elements must be convertible to the same type of elements as the <em>head</em>  stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to concatenate onto the end of the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that concatenates the container onto the stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a1c6e57bccb66cfbfae54134b500ea8c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::drop_while </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drops elements from the stream until the <em>predicate</em>  returns <code>false</code> for a stream element. </p>
<p>All elements before the first <code>false</code> are discarded, the rest are kept, even if later elements would return <code>true</code> for <em>predicate</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The predicate used to drop stream elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that drops stream elements while the <em>predicate</em>  is <code>true</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af694d1a9aa88f1dd8ff3d3e66d2cb6c9" title="Takes elements from the stream until predicate  returns false for an element. ">take_while()</a>, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a></dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../df/d73/drop_while_8cpp-example.html#a0">drop_while.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af375a0d8fadc8ec0e0d2b97a1d2907a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::drop_while </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops elements from the stream until a stream element is <code>false</code>. </p>
<p>All elements before the first <code>false</code> are discarded, the rest are kept, even if later elements are <code>true</code>. This is an overload for streams with types convertible to <code>bool</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that drops stream elements while they are <code>true</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af694d1a9aa88f1dd8ff3d3e66d2cb6c9" title="Takes elements from the stream until predicate  returns false for an element. ">take_while()</a>, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a680ea915183bfa1bd72ff0a342a6bb1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::drop_while </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drops elements from the stream until the <em>member</em>  returns <code>false</code>. </p>
<p>All elements before the first <code>false</code> are discarded, the rest are kept, even if later elements would return <code>true</code> for <em>member</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function used to drop elements, the return type must be convertible to <code>bool</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that drops stream elements while the <em>member</em>  is <code>true</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af694d1a9aa88f1dd8ff3d3e66d2cb6c9" title="Takes elements from the stream until predicate  returns false for an element. ">take_while()</a>, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a></dd></dl>

</div>
</div>
<a class="anchor" id="aa74be97ab2dbd180f7d1127a88cfcf8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::filter </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes elements from the stream that return <code>false</code> for <em>predicate</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The predicate used to filter stream elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that filters the stream elements.</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d0/d76/zip_8cpp-example.html#a2">zip.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a99debd4465f5e92791995d9a985a0a2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes elements from the stream which are evaluated to <code>false</code>. </p>
<p>This is an overload for streams with types convertible to <code>bool</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that filters the stream elements.</dd></dl>

</div>
</div>
<a class="anchor" id="a6e1f3921d4f70c95c8e576ec40f8cdd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::filter </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes elements from the stream that return <code>false</code> for <em>member</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function to use for filtering, the return type must be convertible to <code>bool</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that filters the stream elements.</dd></dl>

</div>
</div>
<a class="anchor" id="ae5917010c6f56abf7ba421dbe0f5e92b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::flat_map </td>
          <td>(</td>
          <td class="paramtype">UnaryOperation&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms each element in the stream using <em>operation</em>  into a new stream. </p>
<p>Each element is transformed into a new stream. The resultant stream is a concatenation of all created streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>The function that creates a new stream from a stream element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that creates new streams and concatenations them together.</dd></dl>

</div>
</div>
<a class="anchor" id="a347e52317b201a9e142031724ea4de0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::limit </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Limits the length of the stream to <em>length</em>  elements. </p>
<p>If the stream is shorter, all elements are kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length to limit the stream at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that limits the length of the stream.</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d7/db4/concat_8cpp-example.html#a2">concat.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af704cfd8b681a9cd8b2437d249487f78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::map </td>
          <td>(</td>
          <td class="paramtype">UnaryOperation&#160;</td>
          <td class="paramname"><em>mapper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms each element in the stream using <em>mapper</em> . </p>
<p>Elements can be mapped to the same type as the source stream, or a new type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapper</td><td>The operation to apply to each element in the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that maps the stream to new values.</dd></dl>

</div>
</div>
<a class="anchor" id="aae7bef0ac778a95140e38bb9e81ae83a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::map </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms each element in the stream to the return value of <em>member</em>  for each stream element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function to use as the transformation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that maps the stream to new values.</dd></dl>

</div>
</div>
<a class="anchor" id="a6fb2b65333a532367af81f9ff82149f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RightSource , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::merge </td>
          <td>(</td>
          <td class="paramtype">Stream&lt; RightSource &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the <em>right</em>  stream into the operated (<em>left</em> ) stream while maintaining sorted order. </p>
<p>Both the <em>left</em>  and <em>right</em>  streams are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. The merge operation is stable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right stream to merge into the left stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that merges the two streams while maintaining sorted order.</dd></dl>

</div>
</div>
<a class="anchor" id="acdce04079f1718a815a7e46718b1c432"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Itr , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::merge </td>
          <td>(</td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the iterator range into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>merge(from(begin, end), compare)</code>. </p>
<p>Both the <em>left</em>  stream and iterator range are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. The merge operation is stable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the range to merge.</td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to merge.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that merges the two streams while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="afacae60f668337190c275857590b158c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Compare  = std::less&lt;void&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::merge </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges <em>container</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>merge(from(container), compare)</code>. </p>
<p>Both the <em>left</em>  stream and <em>container</em>  are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. The merge operation is stable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to merge into the stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that merges the two streams while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a857d36211d87bff95b2e41425933e8ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::merge </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges <em>list</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>merge(from(list), compare)</code>. </p>
<p>Both the <em>left</em>  stream and <em>list</em>  are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. The merge operation is stable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to merge into the stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that merges the two streams while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="ac9078ec57972888d23411f8c3ea209af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::peek </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes <em>action</em>  for each element in the stream. </p>
<p>This does not explicitly change the elements in the stream. The <em>action</em>  is performed, then the stream value is passed on to the next operation. The <em>action</em>  will only be performed if the stream element is actually reached. For example,</p>
<p><code>ints | peek([](int i) { std::cout &lt;&lt; i &lt;&lt; " "; }) | filter(is_even) | ...; // will display all elements<br />
 ints | filter(is_even) | peek([](int i) { std::cout &lt;&lt; i &lt;&lt; " "; }) | ...; // will only display even elements</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The function to apply to each element of the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that executes a function for each stream element.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a6b3d0ede6c9489aebb9ce1ed684c31a0" title="Executes a function for each element in the stream. ">each()</a></dd></dl>

</div>
</div>
<a class="anchor" id="af32b7bf1f105167d576b779b3b5f0297"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::peek </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes <em>member</em>  for each element in the stream. </p>
<p>This does not explicitly change the elements in the stream. The <em>member</em>  is called, then the stream value is passed on to the next operation. The <em>member</em>  will only be called if the stream element is actually reached. For example,</p>
<p><code>things | peek([](Thing&amp; i) { std::cout &lt;&lt; i &lt;&lt; " "; }) | filter(is_something) | ...; // will display all elements<br />
 things | filter(is_something) | peek([](Thing&amp; i) { std::cout &lt;&lt; i &lt;&lt; " "; }) | ...; // will only display "something" elements</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The function to apply to each element of the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that executes a function for each stream element.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a6b3d0ede6c9489aebb9ce1ed684c31a0" title="Executes a function for each element in the stream. ">each()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a11854b160914181e130029b111facf55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::replace </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>replace_by</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces elements in the stream by <em>replace_by</em>  if the stream element returns <code>true</code> for <em>predicate</em> . </p>
<p>Values that return <code>false</code> for <em>predicate</em>  are left unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The predicate, stream elements that return <code>true</code> will be replaced by <em>replace_by</em> .</td></tr>
    <tr><td class="paramname">replace_by</td><td>The value to replace stream elements by when <em>predicate</em>  returns <code>true</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that replaces stream elements.</dd></dl>

</div>
</div>
<a class="anchor" id="a25fa6ade81d666f3e4f85f5ad5502047"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::replace </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces elements in the stream by <em>new_value</em>  if they are equal to <em>old_value</em> . </p>
<p>Equality is checked by using <code>operator==</code> on the elements. Values not equal to <em>old_value</em>  are left unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_value</td><td>The value to replace in the stream by <em>new_value</em> .</td></tr>
    <tr><td class="paramname">new_value</td><td>The value to replace with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that replaces stream elements.</dd></dl>

</div>
</div>
<a class="anchor" id="a0db61e00aa587124edb99e065385ef16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate , typename UnaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::replace_map </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperation&#160;</td>
          <td class="paramname"><em>mapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps stream elements to new values if the original element returns <code>true</code> for <em>predicate</em> . </p>
<p>Values that return <code>false</code> for <em>predicate</em>  are left unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Elements that return <code>true</code> will be mapped through <em>mapper</em> .</td></tr>
    <tr><td class="paramname">mapper</td><td>The mapping operation to apply to elements that return <code>true</code> for <em>predicate</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that replaces stream elements.</dd></dl>

</div>
</div>
<a class="anchor" id="a13397178496f74369fc8dae063415b7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the elements in the stream. </p>
<p>Reversing is an eager operation. On application of the <code>reverse</code> operation, the entire stream up to that point is evaluated and stored before continuing with the remainder of the stream. Thus, the <code>reverse</code> operation takes <code>O(n)</code> extra space and time, where <code>n</code> is the size of the stream. For most applications, it will be beneficial to reverse the stream beforehand by <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad5e12b528b2fa20549b7714efd2a6814" title="Creates a stream over container  in reverse order. ">rfrom()</a> or <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#a19f2046f7478ce9c2ce68e4946ade84d" title="Creates an infinite stream which cycles container  in reverse order. ">rcycle()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that reverses the stream.</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d7/db4/concat_8cpp-example.html#a3">concat.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad934301c4575e60e7fa4f8acac75e471"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RightSource , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_diff </td>
          <td>(</td>
          <td class="paramtype">Stream&lt; RightSource &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the difference of the operated (<em>left</em> ) stream and the <em>right</em>  stream while maintaining sorted order. </p>
<p>The difference operation removes elements from the <em>left</em>  stream if they are in the <em>right</em>  stream and maintains sorted order. This operation is directional, <em>left</em>  <code>-</code> <em>right</em>  is performed. Both the <em>left</em>  and <em>right</em>  streams are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values such that there are more of those elements in the <em>left</em>  stream than the <em>right</em>  stream, the result stream will contain the number by which the count of those elements in the <em>left</em>  stream exceed the count of those elements in the <em>right</em>  stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right stream to difference from the left stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that computes <em>left</em>  <code>-</code> <em>right</em>  while maintaining sorted order.</dd></dl>

</div>
</div>
<a class="anchor" id="ab6e3e38fbff02cb68a8d88ee83f1ed10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Itr , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_diff </td>
          <td>(</td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the difference of the operated (<em>left</em> ) stream and the iterator range while maintaining sorted order, this is the same as <code>set_diff(from(begin, end), compare)</code>. </p>
<p>The difference operation removes elements from the <em>left</em>  stream if they are in the iterator range and maintains sorted order. This operation is directional, <em>left</em>  <code>- [begin, end)</code> is performed. Both the <em>left</em>  stream and iterator range are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values such that there are more of those elements in the <em>left</em>  stream than the iterator range, the result stream will contain the number by which the count of those elements in the <em>left</em>  stream exceed the count of those elements in the iterator range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the range to subtract from <em>left</em> .</td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to subtract from <em>left</em> .</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that computes <em>left</em>  <code>- [begin,end)</code> while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a56200dc064f3c59c0fce20242ae80e4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Compare  = std::less&lt;void&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_diff </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the difference of the operated (<em>left</em> ) stream and <em>container</em>  while maintaining sorted order, this is the same as <code>set_diff(from(container), compare)</code>. </p>
<p>The difference operation removes elements from the <em>left</em>  stream if they are in <em>container</em>  and maintains sorted order. This operation is directional, <em>left</em>  <code>-</code> <em>container</em>  is performed. Both the <em>left</em>  stream and <em>container</em>  are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values such that there are more of those elements in the <em>left</em>  stream than <em>container</em> , the result stream will contain the number by which the count of those elements in the <em>left</em>  stream exceed the count of those elements in <em>container</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to subtract from the stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that computes <em>left</em>  <code>-</code> <em>container</em>  while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="aea643c657fff06efd5a4d7c07fc1659b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_diff </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the difference of the operated (<em>left</em> ) stream and <em>list</em>  while maintaining sorted order, this is the same as <code>set_diff(from(list), compare)</code>. </p>
<p>The difference operation removes elements from the <em>left</em>  stream if they are in <em>list</em>  and maintains sorted order. This operation is directional, <em>left</em>  <code>-</code> <em>list</em>  is performed. Both the <em>left</em>  stream and <em>container</em>  are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values such that there are more of those elements in the <em>left</em>  stream than <em>list</em> , the result stream will contain the number by which the count of those elements in the <em>left</em>  stream exceed the count of those elements in <em>list</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to subtract from the stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that computes <em>left</em>  <code>-</code> <em>list</em>  while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a414b603609b514656419e512f8b8d8c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RightSource , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_intersect </td>
          <td>(</td>
          <td class="paramtype">Stream&lt; RightSource &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersects the <em>right</em>  stream into the operated (<em>left</em> ) stream while maintaining sorted order. </p>
<p>The intersection operation combines both streams keeping only elements in both streams and maintains sorted order. Both the <em>left</em>  and <em>right</em>  streams are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values, the result stream will contain the minimum number of those elements that appear in both streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right stream to intersect with the left stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that intersects the two streams while maintaining sorted order.</dd></dl>

</div>
</div>
<a class="anchor" id="a27ce01f16c8bd1911ed6735ab6876507"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Itr , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_intersect </td>
          <td>(</td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersects the iterator range into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_intersect(from(begin, end), compare)</code>. </p>
<p>The intersection operation combines both streams keeping only elements in both streams and maintains sorted order. Both the <em>left</em>  stream and iterator range are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values, the result stream will contain the minimum number of those elements that appear in both streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the range to intersect.</td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to intersect.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that intersects the two streams while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a9c367fd8127d79dc9b73068cb6f41a6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Compare  = std::less&lt;void&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_intersect </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersects <em>container</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_intersect(from(container), compare)</code>. </p>
<p>The intersection operation combines both streams keeping only elements in both streams and maintains sorted order. Both the <em>left</em>  stream and <em>container</em>  are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values, the result stream will contain the minimum number of those elements that appear in both streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to intersect with the stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that intersects the two streams while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="ad77ba087a55f3703d2d812f8da9655ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_intersect </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersects <em>list</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_intersect(from(list), compare)</code>. </p>
<p>The intersection operation combines both streams keeping only elements in both streams and maintains sorted order. Both the <em>left</em>  stream and <em>list</em>  are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values, the result stream will contain the minimum number of those elements that appear in both streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to intersect with the stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that intersects the two streams while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a16bf95f0e80dcb00c805775a0b799adf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RightSource , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_sym_diff </td>
          <td>(</td>
          <td class="paramtype">Stream&lt; RightSource &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the symmetric difference of the operated (<em>left</em> ) stream and the <em>right</em>  stream while maintaining sorted order. </p>
<p>The symmetric difference operation removes elements present only in both streams and maintains sorted order. Both the <em>left</em>  and <em>right</em>  streams are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. If the source streams contain duplicate values, then the result stream will contain the number by which the count of those elements in one stream exceeds the count in the other stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right stream to difference from the left stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that computes the symmetric difference between <em>left</em>  and <em>right</em>  while maintaining sorted order.</dd></dl>

</div>
</div>
<a class="anchor" id="a5f01de329bfbe82b66fecc70d6fb338b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Itr , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_sym_diff </td>
          <td>(</td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the symmetric difference of the operated (<em>left</em> ) stream and the iterator range while maintaining sorted order, this is the same as <code>set_sym_diff(from(begin, end), compare)</code>. </p>
<p>The symmetric difference operation removes elements present only in both streams and maintains sorted order. Both the <em>left</em>  stream and iterator range are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. If the source streams contain duplicate values, then the result stream will contain the number by which the count of those elements in one stream exceeds the count in the other stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the range to compute symmetric difference with.</td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to to compute symmetric difference with.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that computes the symetric difference between <em>left</em>  and <code>[begin,end)</code> while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a1be578ea731acfba3a2473b5a44e98e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Compare  = std::less&lt;void&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_sym_diff </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the symmetric difference of the operated (<em>left</em> ) stream and <em>container</em>  while maintaining sorted order, this is the same as <code>set_sym_diff(from(container), compare)</code>. </p>
<p>The symmetric difference operation removes elements present only in both streams and maintains sorted order. Both the <em>left</em>  stream and <em>container</em>  are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. If the source streams contain duplicate values, then the result stream will contain the number by which the count of those elements in one stream exceeds the count in the other stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to compute symmetric difference with.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that computes the symmetric difference between <em>left</em>  and <em>container</em>  while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a6fcafd1b53147e51a9af8fab6e35dc5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_sym_diff </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the symmetric difference of the operated (<em>left</em> ) stream and <em>list</em>  while maintaining sorted order, this is the same as <code>set_sym_diff(from(list), compare)</code>. </p>
<p>The symmetric difference operation removes elements present only in both streams and maintains sorted order. Both the <em>left</em>  stream and <em>list</em>  are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. If the source streams contain duplicate values, then the result stream will contain the number by which the count of those elements in one stream exceeds the count in the other stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to compute symmetric difference with.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that computes the symmetric difference between <em>left</em>  and <em>list</em>  while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a497f972f0f5add67935c3bb47a44d104"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RightSource , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_union </td>
          <td>(</td>
          <td class="paramtype">Stream&lt; RightSource &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unions the <em>right</em>  stream into the operated (<em>left</em> ) stream while maintaining sorted order. </p>
<p>The union operation combines both streams but discards duplicates and maintains sorted order. Both the <em>left</em>  and <em>right</em>  streams are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values, the result stream will contain the maximum number of those elements that appear in both streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right stream to union into the left stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that unions the two streams while maintaining sorted order.</dd></dl>

</div>
</div>
<a class="anchor" id="aa7938e2d876a879ee6edf0e2e31ffec8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Itr , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_union </td>
          <td>(</td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unions the iterator range into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_union(from(begin, end), compare)</code>. </p>
<p>The union operation combines both streams but discards duplicates and maintains sorted order. Both the <em>left</em>  stream and iterator range are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values, the result stream will contain the maximum number of those elements that appear in both streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the range to union.</td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to union.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that unions the two streams while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a41227f6665b9a8fcdb8b066ea3226028"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Compare  = std::less&lt;void&gt;, typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_union </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unions <em>container</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_union(from(container), compare)</code>. </p>
<p>The union operation combines both streams but discards duplicates and maintains sorted order. Both the <em>left</em>  stream and <em>container</em>  are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values, the result stream will contain the maximum number of those elements that appear in both streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to union into the stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that unions the two streams while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="ac490fe88e884eed9befb822cedbef139"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::set_union </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unions <em>list</em>  into the operated (<em>left</em> ) stream while maintaining sorted order, this is the same as <code>set_union(from(list), compare)</code>. </p>
<p>The union operation combines both streams but discards duplicates and maintains sorted order. Both the <em>left</em>  stream and <em>list</em>  are assumed to already be sorted according to <em>compare</em> . If not, this operation produces undefined results. By default, <code>operator&lt;</code> is used as the comparator. Elements in the result stream are only from the <em>left</em>  stream. If the source streams contain duplicate values, the result stream will contain the maximum number of those elements that appear in both streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to union into the stream while maintaining sorted order.</td></tr>
    <tr><td class="paramname">compare</td><td>The compare function by which both streams are sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that unions the two streams while maintaining sorted order.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a2725d9fb49cd0c4fe25658500c2fa1f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::skip </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>step_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips the first elements of a stream, keeping only the elements with index <code>&gt;=</code> <em>begin</em>  in the stream. </p>
<p>This operation will skip every <em>step_size</em>  elements after the initial jump to <em>begin</em> . For example a <em>step_size</em>  of 2 will keep only every other element, eg <code>begin, begin+2, begin+4</code> etc. If <em>begin</em>  is out of bounds, then the result is an empty stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The begin index to slice the stream at, inclusive.</td></tr>
    <tr><td class="paramname">step_size</td><td>The step size, must be positive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that slices the stream from <em>begin</em>  to the end skipping every <em>step_size</em>  elements.</dd></dl>

</div>
</div>
<a class="anchor" id="a2f8b2e7e5cc41ecd02cb4381a706d545"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::skip </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>begin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips the first elements of a stream, keeping only the elements with index <code>&gt;=</code> <em>begin</em>  in the stream. </p>
<p>If <em>begin</em>  is out of bounds, then the result is an empty stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The begin index to slice the stream at, inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that slices the stream from <em>begin</em>  to the end.</dd></dl>

</div>
</div>
<a class="anchor" id="aeef64fd0f533b9b084b83c46fe8352d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::skip_every </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>step_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips every <em>step_size</em>  elements in the stream, keeping the first element. </p>
<p>For example, a <em>step_size</em>  of 2 will only keep stream elements with index 0, 2, 4 etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step_size</td><td>The step size, must be positive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that skips every <em>step_size</em>  elements.</dd></dl>

</div>
</div>
<a class="anchor" id="a1954e2f5425b7603794790f7645e776e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::slice </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>step_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slices the stream, keeping only elements with index in the range <code>[begin..end)</code> in the stream, excluding the <em>end</em>  index. </p>
<p>If <em>end</em>  is out of bounds of the stream, the entire stream from <em>begin</em>  is kept. If <em>begin</em>  is out of bounds, then the result is an empty stream. The operation will skip every <em>step_size</em>  elements in the slice. For example a <em>step_size</em>  of 2 will keep only every other element in the range, eg <code>begin, begin+2, begin+4</code> etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The begin index to slice the stream at, inclusive.</td></tr>
    <tr><td class="paramname">end</td><td>The end index to slice to stream to, exclusive.</td></tr>
    <tr><td class="paramname">step_size</td><td>The step size, must be positive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that slices the stream to the given range.</dd></dl>

</div>
</div>
<a class="anchor" id="ac8468b308d2903331dc966819b373625"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::slice </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slices the stream, keeping only elements with index in the range <code>[begin..end)</code> in the stream, excluding the <em>end</em>  index. </p>
<p>If <code>end</code> is out of bounds of the stream, the entire stream from <em>begin</em>  is kept. If <em>begin</em>  is out of bounds, then the result is an empty stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The begin index to slice the stream at, inclusive.</td></tr>
    <tr><td class="paramname">end</td><td>The end index to slice to stream to, exclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that slices the stream to the given range.</dd></dl>

</div>
</div>
<a class="anchor" id="a0641d6ecc741bd5f346a961e5e8ccf44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::sort </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the stream using the given comparator, <code>operator&lt;</code> by default. </p>
<p>Sorting is an eager operation. On application of the <code>sort</code> operation, the entire stream up to that point is evaluated and stored, then finally sorted before continuing with the sorted version of the stream. Thus, the <code>sort</code> operation takes <code>O(n)</code> extra space and time to copy the stream, and the additional <code>O(n logn)</code> to sort, where <code>n</code> is the size of the stream. For most applications, it will be beneficial to sort the source of the stream beforehand if possible. For example, the following should be <em>avoided</em>:</p>
<p><code>int min = my_vector | <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a0641d6ecc741bd5f346a961e5e8ccf44" title="Sorts the stream using the given comparator, operator< by default. ">sort()</a> | <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae2088cf5443957cdf935652bccc0b612" title="Returns the first element from the stream. ">first()</a>; // just an example</code> </p>
<p>Instead, sorting the container in place beforehand will be more efficient as no additional copying takes place.</p>
<p><code>std::sort(my_vector.begin(), my_vector.end());<br />
 int min = my_vector | <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae2088cf5443957cdf935652bccc0b612" title="Returns the first element from the stream. ">first()</a>;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The compare function, by default <code>std::less&lt;void&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that sorts the stream according to the compare function.</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d1/d7e/sort_8cpp-example.html#a1">sort.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab9a5f0773de4aac232e80ae23495e76e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::stable_sort </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the stream preserving relative order of elements using the given comparator, <code>operator&lt;</code> by default. </p>
<p>Sorting is an eager operation. On application of the <code>stable_sort</code> operation, the entire stream up to that point is evaluated and stored, then finally sorted before continuing with the sorted version of the stream. Thus, the <code>stable_sort</code> operation takes <code>O(n)</code> extra space and time to copy the stream, and the additional <code>O(n logn)</code> to sort, where <code>n</code> is the size of the stream. For most applications, it will be beneficial to sort the source of the stream beforehand if possible. For example, the following should be <em>avoided</em>:</p>
<p><code>int min = my_vector | <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ab9a5f0773de4aac232e80ae23495e76e" title="Sorts the stream preserving relative order of elements using the given comparator, operator< by default. ">stable_sort()</a> | <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae2088cf5443957cdf935652bccc0b612" title="Returns the first element from the stream. ">first()</a>; // just an example</code> </p>
<p>Instead, sorting the container in place beforehand will be more efficient as no additional copying takes place.</p>
<p><code>std::stable_sort(my_vector.begin(), my_vector.end());<br />
 int min = my_vector | <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae2088cf5443957cdf935652bccc0b612" title="Returns the first element from the stream. ">first()</a>;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The compare function, by default <code>std::less&lt;void&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that stable sorts the stream according to the compare function.</dd></dl>

</div>
</div>
<a class="anchor" id="af694d1a9aa88f1dd8ff3d3e66d2cb6c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::take_while </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes elements from the stream until <em>predicate</em>  returns <code>false</code> for an element. </p>
<p>Elements after and including the first <code>false</code> are discarded, even if later elements would return <code>true</code> for <em>predicate</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The predicate used to take stream elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that takes stream elements while <em>predicate</em>  returns <code>true</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a1c6e57bccb66cfbfae54134b500ea8c0" title="Drops elements from the stream until the predicate  returns false for a stream element. ">drop_while()</a>, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a213755b414a7d31af11bb96c129c6667"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::take_while </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes elements from the stream until an element is <code>false</code>. </p>
<p>Elements after and including the first <code>false</code> are discarded, even if later elements are <code>true</code>. This is an overload for streams with types convertible to <code>bool</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that takes stream elements while they are <code>true</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a1c6e57bccb66cfbfae54134b500ea8c0" title="Drops elements from the stream until the predicate  returns false for a stream element. ">drop_while()</a>, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a></dd></dl>

</div>
</div>
<a class="anchor" id="adf3882ef78e687785e2c1402e4a62ea1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::take_while </td>
          <td>(</td>
          <td class="paramtype">Ret(Class::*)()&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes elements from the stream until the <em>member</em>  returns <code>false</code>. </p>
<p>Elements after and including the first <code>false</code> are discarded, even if later elements would return <code>true</code> for <em>member</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>The class member function used to take elements, the return type must be convertible to <code>bool</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that takes stream elements while the <em>member</em>  is <code>true</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a1c6e57bccb66cfbfae54134b500ea8c0" title="Drops elements from the stream until the predicate  returns false for a stream element. ">drop_while()</a>, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a304866b3dec4eafe95a024319328ef2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compare  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::unique </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>Compare()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts and extracts only unique elements from the stream. </p>
<p>By default, <code>operator&lt;</code> is used for comparisons. As with sorting, this operation is eager, the entire stream up to this operation's application is evaluated and stored. Thus, the <code>unique</code> operation takes <code>O(n)</code> extra space and time plus <code>O(n logn)</code> time to sort, where <code>n</code> is the size of the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The compare function, by default <code>std::less&lt;void&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that sorts the stream according to the compare function and keeps only unique elements.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a0641d6ecc741bd5f346a961e5e8ccf44" title="Sorts the stream using the given comparator, operator< by default. ">sort()</a></dd></dl>

</div>
</div>
<a class="anchor" id="ae25b0a8475258acc29173c4a37e13e22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RightSource , typename BinaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::zip </td>
          <td>(</td>
          <td class="paramtype">Stream&lt; RightSource &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>zipper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips the two streams together using <em>zipper</em>  as the zipping operation. </p>
<p>A zipping operation is any function that takes the front element from both streams as input and produces a single output which is used for the resultant stream. The resultant stream is as long as the shortest input stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right stream to zip together with the operated stream.</td></tr>
    <tr><td class="paramname">zipper</td><td>The zipping operation that combines the two streams.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that zips the two streams.</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d0/d76/zip_8cpp-example.html#a0">zip.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afb00402c75a7be66d0d82652d275889d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Itr , typename BinaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::zip </td>
          <td>(</td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>zipper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips the two streams together using <em>zipper</em>  as the zipping operation, this is the same as <code>zip(from(begin, end), zipper)</code>. </p>
<p>A zipping operation is any function that takes an element from either stream as input and produces a single output which is used for the resultant stream. The resultant stream is as long as the shortest input stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the range to zip with this stream.</td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to zip with this stream.</td></tr>
    <tr><td class="paramname">zipper</td><td>The zipping operation that combines the two streams.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that zips the two streams.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a573b95c3fc149372b6659127f7d47814"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename BinaryOperation , typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::zip </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>zipper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips the two streams together using <em>zipper</em>  as the zipping operation, this is the same as <code>zip(from(container), zipper)</code>. </p>
<p>A zipping operation is any function that takes an element from either stream as input and produces a single output which is used for the resultant stream. The resultant stream is as long as the shortest input stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to zip together with this stream.</td></tr>
    <tr><td class="paramname">zipper</td><td>The zipping operation that combines the two streams.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that zips the two streams.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a7916efdf915b8224595dd84557f20874"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename BinaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::zip </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>zipper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips the two streams together using <em>zipper</em>  as the zipping operation, this is the same as <code>zip(from(list), zipper)</code>. </p>
<p>A zipping operation is any function that takes an element from either stream as input and produces a single output which is used for the resultant stream. The resultant stream is as long as the shortest input stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to zip together with this stream.</td></tr>
    <tr><td class="paramname">zipper</td><td>The zipping operation that combines the two streams.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that zips the two streams.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a7f1ec0323daa06ef6b093f1d0aa4c1cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RightSource &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::zip </td>
          <td>(</td>
          <td class="paramtype">Stream&lt; RightSource &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips the two streams together using the default zipping operation. </p>
<p>The default zip operation creates tuples of the stream elements like <code>std::tuple&lt;T1&amp;, T2&amp;&gt;</code>. Multiple <code>zip</code> operations concatenates these tuples together rather than nesting them.</p>
<p>The resultant stream is as long as the shortest input stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right stream to zip together with the operated stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that zips the two streams.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/de2/namespaceflow.html#ad795c672b7e52516485e7ffb2d6c4ad7" title="Uncurries curry_function . ">uncurry()</a></dd></dl>

</div>
</div>
<a class="anchor" id="af07acbb7524420dd6b7b05f609212395"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Itr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::zip </td>
          <td>(</td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips the two streams together using the default zipping operation, this is the same as <code>zip(from(begin, end))</code>. </p>
<p>The default zip operation creates tuples of the stream elements like <code>std::tuple&lt;T1&amp;, T2&amp;&gt;</code>. Multiple <code>zip</code> operations concatenates these tuples together rather than nesting them.</p>
<p>The resultant stream is as long as the shortest input stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the range to zip with this stream.</td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to zip with this stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that zips the two streams.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a>, <a class="el" href="../../d9/de2/namespaceflow.html#ad795c672b7e52516485e7ffb2d6c4ad7" title="Uncurries curry_function . ">uncurry()</a></dd></dl>

</div>
</div>
<a class="anchor" id="ab2fc82a612a709360fac445a46001509"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename  = std::enable_if_t&lt;generator::detail::has_const_iterator&lt;Container&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::zip </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips the two streams together using the default zipping operation, this is the same as <code>zip(from(container))</code>. </p>
<p>The default zip operation creates tuples of the stream elements like <code>std::tuple&lt;T1&amp;, T2&amp;&gt;</code>. Multiple <code>zip</code> operations concatenates these tuples together rather than nesting them.</p>
<p>The resultant stream is as long as the shortest input stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to zip together with this stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that zips the two streams.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a>, <a class="el" href="../../d9/de2/namespaceflow.html#ad795c672b7e52516485e7ffb2d6c4ad7" title="Uncurries curry_function . ">uncurry()</a></dd></dl>

</div>
</div>
<a class="anchor" id="ab5b531057c1a25cd2488f1f6817c0d63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto flow::intermediate::zip </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips the two streams together using the default zipping operation, this is the same as <code>zip(from(list))</code>. </p>
<p>The default zip operation creates tuples of the stream elements like <code>std::tuple&lt;T1&amp;, T2&amp;&gt;</code>. Multiple <code>zip</code> operations concatenates these tuples together rather than nesting them.</p>
<p>The resultant stream is as long as the shortest input stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to zip together with this stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An intermediate operation that zips the two streams.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a>, <a class="el" href="../../d9/de2/namespaceflow.html#ad795c672b7e52516485e7ffb2d6c4ad7" title="Uncurries curry_function . ">uncurry()</a></dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
