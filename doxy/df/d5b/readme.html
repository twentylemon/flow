<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Flow: Readme</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Flow
   </div>
   <div id="projectbrief">Lazy Evaluated Stream Processing in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Readme </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#compilers">Compiler Support</a></li>
<li class="level1"><a href="#install">Installation</a><ul><li class="level2"><a href="#build">Build a Sample Program</a></li>
</ul>
</li>
<li class="level1"><a href="#use">Using the Library</a><ul><li class="level2"><a href="#stream">Understanding Streams</a></li>
<li class="level2"><a href="#generator">Stream Generators</a></li>
<li class="level2"><a href="#operations">Stream Operations</a><ul><li class="level3"><a href="#intermediate">Intermediate Operations</a></li>
<li class="level3"><a href="#terminal">Terminal Operations</a></li>
<li class="level3"><a href="#pipe">The Pipe Operator</a></li>
</ul>
</li>
<li class="level2"><a href="#infinite">Infinite Streams</a></li>
<li class="level2"><a href="#iteration">Custom Iteration</a></li>
</ul>
</li>
<li class="level1"><a href="#feedback">Feedback</a></li>
</ul>
</div>
<div class="textblock"><p>This page contains everything you'll need to know in order to start using the flow library.</p>
<h1><a class="anchor" id="compilers"></a>
Compiler Support</h1>
<p>The flow library is known to work for the following compilers.</p>
<ul>
<li>
g++ 4.9 and g++ 5.0 </li>
<li>
clang 3.5 </li>
<li>
msvc 14.0 (visual studio 2015) </li>
</ul>
<p>The flow library requires compilation under the C++14 standard. For g++/clang, this requires the <code>-std=c++14</code> flag. MSVC 14.0 automatically compiles under the C++14 standard.</p>
<p>Flow performs best on MSVC in most cases. The library also performs well for built-in or smaller types in g++ or clang.</p>
<h1><a class="anchor" id="install"></a>
Installation</h1>
<p>The flow library is header-only, so there's nothing to build. Download a release from the <a href="https://github.com/twentylemon/flow">GitHub repository</a> and place the <code>include</code> directory where you want the flow library to live. Then, in your program, the <code>#include</code> directive will be similar to <code>#include &lt;<a class="el" href="../../da/d76/flow_8h.html">flow.h</a>&gt;</code> depending on your preference regarding the include path.</p>
<h2><a class="anchor" id="build"></a>
Build a Sample Program</h2>
<p>The following program computes the sum of squares of the numbers 1 to 10, displaying each square and the sum to <code>std::cout</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../da/d76/flow_8h.html">flow.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { </div>
<div class="line">    <a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#ae2c64ec27f78b22d4652a5df27985a17">flow::closed_range</a>(1, 10)</div>
<div class="line">        | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78">flow::map</a>([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i * i; })</div>
<div class="line">        | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac9078ec57972888d23411f8c3ea209af">flow::peek</a>([](<span class="keywordtype">int</span> i) { std::cout &lt;&lt; <span class="stringliteral">&quot;value = &quot;</span> &lt;&lt; i &lt;&lt; std::endl; })</div>
<div class="line">        | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381">flow::sum</a>().then([](<span class="keyword">auto</span>&amp; s) { std::cout &lt;&lt; <span class="stringliteral">&quot;total = &quot;</span> &lt;&lt; *s &lt;&lt; std::endl; });</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <p>Copy the above program into a file and try to compile and run it to verify the installation. The output of the program should be:</p>
<div class="fragment"><div class="line">value = 1</div>
<div class="line">value = 4</div>
<div class="line">value = 9</div>
<div class="line">value = 16</div>
<div class="line">value = 25</div>
<div class="line">value = 36</div>
<div class="line">value = 49</div>
<div class="line">value = 64</div>
<div class="line">value = 81</div>
<div class="line">value = 100</div>
<div class="line">total = 385</div>
</div><!-- fragment --><h1><a class="anchor" id="use"></a>
Using the Library</h1>
<p>This section will go into detail about everything you need to know in order to use the library effectively.</p>
<h2><a class="anchor" id="stream"></a>
Understanding Streams</h2>
<p>What is a stream? You can think of a stream as a single pass sequence of elements which you can manipulate or process in some way. It's sort of like a container that doesn't own its elements &ndash; stream elements in flow will typically be references to elements in an actual container, or be generated temporary variables. Streams don't <em>store</em> elements, the elements are instead <em>computed</em> once they are needed.</p>
<p>Streams are <em>single-pass</em> &ndash; this means they can only be iterated through once. Iterating through a stream will be referred to as <em>using</em> the stream, and an iterated through stream will be referred to as <em>used</em>. Using a stream that has already been used will lead to undefined behavior. <span style="font-size:0.8em">[Typically, it produces an empty stream, but this behavior is not guaranteed.]</span></p>
<p>Streams allow for <em>pipelining</em> of operations in a simple syntax. Many stream operations create new streams, which allows multiple operations to be chained to form a pipeline. Other operations will iterate through the stream implicitly to calculate some result. In the <a class="el" href="../../df/d5b/readme.html#build">Build a Sample Program</a> example, we can see a stream pipeline. This example shows a very simple use case, calculating the sum of the squares of the numbers 1 to 10. Contrary to vanilla code, the first operation that takes place, <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381" title="Returns the sum of all the elements in the stream using operator+ as an optional. ...">sum()</a>, requests a value. It asks if the operation before it in the pipeline, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac9078ec57972888d23411f8c3ea209af" title="Executes action  for each element in the stream. ">peek()</a>, has another element. <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac9078ec57972888d23411f8c3ea209af" title="Executes action  for each element in the stream. ">peek()</a> gets this request, but is not a stream source, so it asks the previous thing in the pipeline the same question. <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a> defers back again, and finally, <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ae2c64ec27f78b22d4652a5df27985a17" title="Creates a stream containing the elements in the range [lower, upper], including upper ...">closed_range()</a>, the source of the stream, can say "Yes! Have a 1." That 1 is passed up the pipeline to <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a>, which squares the 1 into 1, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac9078ec57972888d23411f8c3ea209af" title="Executes action  for each element in the stream. ">peek()</a> displays the (squared) 1 before forwarding it to <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381" title="Returns the sum of all the elements in the stream using operator+ as an optional. ...">sum()</a> who can finally use the value. Current sum is 1, hurray! This process is then repeated &ndash; <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381" title="Returns the sum of all the elements in the stream using operator+ as an optional. ...">sum()</a> requests another value; it is piped up to <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ae2c64ec27f78b22d4652a5df27985a17" title="Creates a stream containing the elements in the range [lower, upper], including upper ...">closed_range()</a> which gives 2 this time; <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a> makes it 4; <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac9078ec57972888d23411f8c3ea209af" title="Executes action  for each element in the stream. ">peek()</a> displays it; <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381" title="Returns the sum of all the elements in the stream using operator+ as an optional. ...">sum()</a> tallies it and requests another. Eventually, <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ae2c64ec27f78b22d4652a5df27985a17" title="Creates a stream containing the elements in the range [lower, upper], including upper ...">closed_range()</a> will not have any more elements to give so the stream iteration stops and the sum is returned.</p>
<p>Naturally, more complex pipelines can be created. We can slightly modify the above example to calculate the sum of the <em>even</em> numbers from 1 to 10. The following code will calculate and display that sum.</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#ae2c64ec27f78b22d4652a5df27985a17">flow::closed_range</a>(1, 10)</div>
<div class="line">    | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c">flow::filter</a>([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; })</div>
<div class="line">    | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78">flow::map</a>([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i * i; })</div>
<div class="line">    | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381">flow::sum</a>().then([](<span class="keyword">auto</span>&amp; s) { std::cout &lt;&lt; <span class="stringliteral">&quot;total = &quot;</span> &lt;&lt; *s &lt;&lt; std::endl; });</div>
</div><!-- fragment --> <p>Here, we added <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a> to the mix, which only keeps stream elements that return <code>true</code> for the predicate &ndash; even values, in this case. In this example, the process follows the same flow: <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381" title="Returns the sum of all the elements in the stream using operator+ as an optional. ...">sum()</a> requests an element from <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a>, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a> in turn requests from <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a>, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a> requests from <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ae2c64ec27f78b22d4652a5df27985a17" title="Creates a stream containing the elements in the range [lower, upper], including upper ...">closed_range()</a> which gives a value: 1. Here is where it is different: the 1 is passed to <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a>, but <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a> does not accept odd values, so it is rejected and the pipeline stops; a new value is immediately requested. <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ae2c64ec27f78b22d4652a5df27985a17" title="Creates a stream containing the elements in the range [lower, upper], including upper ...">closed_range()</a> doesn't mind, it gives the next value: 2 to <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a>; <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a> accepts and passes it to <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a>, <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a> squares it and passes 4 to <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381" title="Returns the sum of all the elements in the stream using operator+ as an optional. ...">sum()</a> which finally uses the <em>first</em> value. Current sum is 4, hurray!</p>
<p>You can watch the pipeline work with some print statements. Try the following code for yourself:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#ae2c64ec27f78b22d4652a5df27985a17">flow::closed_range</a>(1, 5) <span class="comment">// note: 1 to 5</span></div>
<div class="line">    | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c">flow::filter</a>([](<span class="keywordtype">int</span> i) { std::cout &lt;&lt; <span class="stringliteral">&quot;filter: &quot;</span> &lt;&lt; i &lt;&lt; std::endl; <span class="keywordflow">return</span> i % 2 == 0; })</div>
<div class="line">    | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78">flow::map</a>([](<span class="keywordtype">int</span> i) { std::cout &lt;&lt; <span class="stringliteral">&quot;map: &quot;</span> &lt;&lt; i &lt;&lt; std::endl; <span class="keywordflow">return</span> i * i; })</div>
<div class="line">    | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381">flow::sum</a>().then([](<span class="keyword">auto</span>&amp; s) { std::cout &lt;&lt; <span class="stringliteral">&quot;total = &quot;</span> &lt;&lt; *s &lt;&lt; std::endl; });</div>
</div><!-- fragment --> <p>It is the same as above, except both <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a> and <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a> display to <code>std::cout</code> when they are doing work. This code will display the following.</p>
<div class="fragment"><div class="line"><a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c">filter</a>: 1</div>
<div class="line"><a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c">filter</a>: 2</div>
<div class="line"><a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78">map</a>: 2</div>
<div class="line"><a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c">filter</a>: 3</div>
<div class="line"><a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c">filter</a>: 4</div>
<div class="line"><a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78">map</a>: 4</div>
<div class="line"><a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c">filter</a>: 5</div>
<div class="line">total = 20</div>
</div><!-- fragment --><h2><a class="anchor" id="generator"></a>
Stream Generators</h2>
<p>Creating a stream is simple using the factory methods provided in the <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html" title="Factory methods to create stream objects, all of which are also aliased in the flow namespace...">flow::generator</a> namespace. The most common method is to create a stream over a container using <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b" title="Creates a stream from the given iterator range. ">from()</a>. Since it's so common, the <code>operator|</code> is overloaded for container types with stream operations, so the following two lines produce the same result.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec = { ... };</div>
<div class="line"><span class="keywordtype">int</span> s1 = <a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#ad70162f218f4b05d3ad1a3dca7f1cd3b">flow::from</a>(vec) | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381">flow::sum</a>(0);</div>
<div class="line"><span class="keywordtype">int</span> s2 = vec | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381">flow::sum</a>(0);</div>
<div class="line">assert(s1 == s2);</div>
</div><!-- fragment --> <p>Other common generators include <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad3e468cd8e943a73900891b99f7a2ded" title="Creates an infinite stream of values by incrementing begin  using operator++. ">iota()</a> and <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#a45f23c30d0db685703bc80c1daf19840" title="Creates a stream containing the elements in the range [lower, upper), excluding upper ...">range()</a>, which count up from a value, or <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ac91cc015f53a6efeea386b04b9486572" title="Creates an infinite stream containing value  repeated over and over. ">repeat()</a>, which repeats a value. These generators actually produce <em>infinite</em> streams, more information about these is available in the <a class="el" href="../../df/d5b/readme.html#infinite">Infinite Streams</a> section.</p>
<h2><a class="anchor" id="operations"></a>
Stream Operations</h2>
<p>We've seen some examples and understand the flow behind the scenes, but we haven't explained what the stream operations are, what they are doing, and what <code>operator|</code> is doing precisely.</p>
<p>Stream operations can be broken down into two main types: intermediate and terminal. Intermediate operations transform the stream somehow (<a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a> or <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a>), while terminal operations iterate through the stream and use the values somehow (<a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381" title="Returns the sum of all the elements in the stream using operator+ as an optional. ...">sum()</a>).</p>
<h3><a class="anchor" id="intermediate"></a>
Intermediate Operations</h3>
<p>Intermediate operations somehow transform a stream into a new one. Just above, we used <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a> to transform the stream created by <code>closed_range(1, 5)</code> into a stream only containing the even values in the range; the stream was transformed again using <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a>. Intermediate operations do not use the stream in any way, they simply change the way the stream behaves once it is used.</p>
<p>Intermediate operations are further divided into <em>stateless</em> and <em>stateful</em> operations. Most operations are stateless, such as <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c" title="Removes elements from the stream that return false for predicate . ">filter()</a> and <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a>. Stateless operations don't care about the state of the stream as a whole and thus only require <code>O(1)</code> space and time. Stateful operations, such as <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#a0641d6ecc741bd5f346a961e5e8ccf44" title="Sorts the stream using the given comparator, operator< by default. ">sort()</a>, need to know about the entire stream. They accomplish this by copying the stream into a <code>std::vector</code>. These are especially expensive operations and generally should be avoided when performance is a concern. Stateful operations require an additional <code>O(n)</code> space and at least <code>O(n)</code> time, where <code>n</code> is the size of the stream.</p>
<p>Intermediate operations are all contained in the <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html" title="Intermediate operations, all of which are also aliased in the flow namespace. ">flow::intermediate</a> namespace.</p>
<h3><a class="anchor" id="terminal"></a>
Terminal Operations</h3>
<p>Terminal operations use the streams they are applied to in order to produce a result or a side effect. Above, we used <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381" title="Returns the sum of all the elements in the stream using operator+ as an optional. ...">sum()</a> to add all the elements, and <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#acc0afd1d9f8846d76814248e4d6a164f" title="Prints the stream elements to out  with delimiter  printed after each element. ">dump()</a> to write them all into a file.</p>
<p>Terminal operations built into the flow library contain several shorthand methods which allow you to directly use the value returned by the terminal in another function. In the example in <a class="el" href="../../df/d5b/readme.html#build">Build a Sample Program</a>, we used <code>then()</code> to immediate display the sum. There are also methods to directly access the value inside a <a class="el" href="../../d6/d3f/classflow_1_1optional.html">flow::optional</a> object, which are returned by several of the terminal operations in the library. These methods are described below. More information is available on the <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html" title="Terminal operations, all of which are also aliased in the flow namespace. ">flow::terminal</a> namespace page, and examples in <a class="el" href="../../df/de0/terminal_8cpp-example.html">terminal.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// call &quot;value&quot; the normal return value of *this terminal</span></div>
<div class="line">.then(F f);         <span class="comment">// return `f(value)`</span></div>
<div class="line"><span class="comment">// the following should only be used if `value` is an instance of flow::optional</span></div>
<div class="line">.value();           <span class="comment">// return `*value` without error checking</span></div>
<div class="line">.value_or(T v);     <span class="comment">// return `value.value_or(v)`; `*value` if it exists, `v` otherwise</span></div>
<div class="line">.if_then(F f, G g = [](){});    <span class="comment">// return `f(*value)` if value exists, otherwise return `g()`</span></div>
</div><!-- fragment --> <p>Terminal operations are all contained in the <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html" title="Terminal operations, all of which are also aliased in the flow namespace. ">flow::terminal</a> namespace.</p>
<h3><a class="anchor" id="pipe"></a>
The Pipe Operator</h3>
<p>All stream operations are <em>lazy</em>, meaning the operation itself does not do any work. The operation only does work once it is <em>applied</em> to a stream using <code>operator|</code>. In short, <code>operator|</code> is the thing that tells the operations to operate.</p>
<p>The <code>operator|</code> is also overloaded between operations so you can compose your own and create new ones. For example, say you use the "keeps evens and square" intermediate operation frequently. You can store this operation in a variable or create a function that returns this operation.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> even_squares = <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c">flow::filter</a>([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; }) | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78">flow::map</a>([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i * i; });</div>
<div class="line"><span class="keyword">auto</span> write_out = <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#ac9078ec57972888d23411f8c3ea209af">flow::peek</a>([](<span class="keywordtype">int</span> i) { std::cerr &lt;&lt; <span class="stringliteral">&quot;writing &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; to file&quot;</span> &lt;&lt; std::endl; }) | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#acc0afd1d9f8846d76814248e4d6a164f">flow::dump</a>(output_file, <span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"><a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#ae2c64ec27f78b22d4652a5df27985a17">flow::closed_range</a>(1, 10)</div>
<div class="line">    | even_squares</div>
<div class="line">    | write_out;</div>
</div><!-- fragment --> <p>The type of operation you create is the same type as the last operation you compose. The <code>even_squares</code> operation above is an intermediate operation because <a class="el" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78" title="Transforms each element in the stream using mapper . ">map()</a> is an intermediate operation. The <code>write_out</code> operation is a terminal operation because <a class="el" href="../../d1/d6c/namespaceflow_1_1terminal.html#acc0afd1d9f8846d76814248e4d6a164f" title="Prints the stream elements to out  with delimiter  printed after each element. ">dump()</a> is a terminal operation.</p>
<h2><a class="anchor" id="infinite"></a>
Infinite Streams</h2>
<p>Since streams are lazily evaluated, they can represent an infinite series of elements. A simple example of this is the <a class="el" href="../../de/d3f/namespaceflow_1_1generator.html#ad3e468cd8e943a73900891b99f7a2ded" title="Creates an infinite stream of values by incrementing begin  using operator++. ">iota()</a> generator, which counts up from a value. You can use infinite streams in the same manner as you would finite streams, but be aware of when you use infinite streams, you must somehow stop the stream evaluation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> infinity = <a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#ad3e468cd8e943a73900891b99f7a2ded">flow::iota</a>(1) | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#a4fe0dda56d4f64d94e607e73b9187960">flow::last</a>().value(); <span class="comment">// this will never stop</span></div>
<div class="line">std::vector&lt;int&gt; rands = <a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#a5b8fd258f7d86d373d2f2126ecbdcad2">flow::generate</a>(std::rand) | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae65b798b18b47576c1ffed6f63814fc0">flow::to_vector</a>(); <span class="comment">// also bad, but this will happily crash once memory allocation fails</span></div>
<div class="line">rands = <a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#a5b8fd258f7d86d373d2f2126ecbdcad2">flow::generate</a>(std::rand) | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#a347e52317b201a9e142031724ea4de0a">flow::limit</a>(i_want_this_many) | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae65b798b18b47576c1ffed6f63814fc0">flow::to_vector</a>();  <span class="comment">// good! explicitly limit the length</span></div>
<div class="line"><span class="keywordtype">bool</span> has_10 = <a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#abb3555c44d1d02606702664c76473ff5">flow::random_ints</a>(1, 9) | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#a07ed2f12c748c9f2790416391318a597">flow::contains</a>(10); <span class="comment">// never stops; values between 1 and 9 never contains 10</span></div>
<div class="line">has_10 = <a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#abb3555c44d1d02606702664c76473ff5">flow::random_ints</a>(1, 10000) | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#a07ed2f12c748c9f2790416391318a597">flow::contains</a>(10);  <span class="comment">// *could* stop, but who knows when</span></div>
</div><!-- fragment --> <p>Also note that infinite streams are never totally used, so the following would be totally acceptable.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> randoms = <a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#a340e9dfc2414410ce89d9e039a33736e">flow::random_reals</a>(0.0, 1.0);</div>
<div class="line">std::vector&lt;double&gt; vec = randoms | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#a347e52317b201a9e142031724ea4de0a">flow::limit</a>(1000) | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#ae65b798b18b47576c1ffed6f63814fc0">flow::to_vector</a>();  <span class="comment">// store 1,000 of them</span></div>
<div class="line"><span class="keywordtype">double</span> val = randoms | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#a347e52317b201a9e142031724ea4de0a">flow::limit</a>(100000) | <a class="code" href="../../d1/d6c/namespaceflow_1_1terminal.html#a9d36eab187f4b501c07a00f39e4f2381">flow::sum</a>().value();           <span class="comment">// sum 100,000 of them; randoms is not totally used</span></div>
</div><!-- fragment --><h2><a class="anchor" id="iteration"></a>
Custom Iteration</h2>
<p>If none of the provided intermediate or terminal operations do exactly what you need them to do, you can always iterate through a stream yourself in the same manner as you would any container. Acquire the stream you want, then use the methods <code>begin()</code> and <code>end()</code> to access the stream iterators, or use the range-based for loop. Remember though, once a stream is used, it cannot be used again.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> stream = people</div>
<div class="line">    | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c">flow::filter</a>([](Person&amp; p) { <span class="keywordflow">return</span> p.sex() == Person::Sex::Male; })</div>
<div class="line">    | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78">flow::map</a>(&amp;Person::age);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> age : stream) {</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"><span class="comment">// be careful! stream is used and cannot be used again.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// you can also use the stream directly in the range-based for loop</span></div>
<div class="line"><span class="comment">// the stream is a temporary, so whether or not it is used doesn&#39;t matter anymore</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; e : <a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#a45f23c30d0db685703bc80c1daf19840">range</a>(1, 100) | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#aa74be97ab2dbd180f7d1127a88cfcf8c">filter</a>([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; }) | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78">map</a>([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i*i; })) {</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> ages = people | <a class="code" href="../../dc/d09/namespaceflow_1_1intermediate.html#af704cfd8b681a9cd8b2437d249487f78">flow::map</a>(&amp;Person::age);</div>
<div class="line"><span class="keywordtype">bool</span> eq = std::equal(ages.begin(), ages.end(), other_thing.begin());</div>
<div class="line"><span class="comment">// ages may or may not be used entirely -- you should consider it to be used</span></div>
</div><!-- fragment --> <p>The stream iterators also work for infinite streams, technically. The past-the-end iterator will never be reached by incrementing. Ensure you have some sort of stopping condition for infinite streams, same as you always would.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> counter = <a class="code" href="../../de/d3f/namespaceflow_1_1generator.html#ad3e468cd8e943a73900891b99f7a2ded">flow::iota</a>(0);</div>
<div class="line"><span class="keywordtype">bool</span> eq = std::equal(vec.begin(), vec.end(), counter.begin());  <span class="comment">// counter is stepped to where ever the function stopped incrementing</span></div>
</div><!-- fragment --><h1><a class="anchor" id="feedback"></a>
Feedback</h1>
<p>Let me know of any bugs, performance issues or possible additions to the library by opening an issue on the <a href="https://github.com/twentylemon/flow">GitHub repository</a>. If you like the project, let me know by starring or forking!</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
