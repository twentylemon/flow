
/// \mainpage
/// Sick Flow, Bro
/// ==============
/// <para>Inspired by Java 8 [Streams](http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html),
/// flow is a C++14 library that provides lazy evaluation and functional transformations on data. It's like Haskell for C++.
/// The library provides many common data transformations, such as map, filter and fold, as well as other commonly used
/// operations like computing the sum, min and max or simply counting the number or elements. And all of it is packaged
/// in a nice, easy to read and understand syntax. To use, simply <c>\#include &lt;flow.h&gt;</c> in your C++14 program.
/// With fully optimized code (<c>-O3</c> or <c>/O2</c>), flow offers minimal performance penalties compared to
/// standard code, so there's no reason not to love.</para>
/// 
/// What is a Sick Flow?
/// --------------------
/// <para>A flow is usually called a stream. But if I called the library "Stream" I couldn't say "sick flow" all the time.
/// I'll use flow and stream interchangeably, just know that a stream is a source of data, data that you would want to
/// do things with.</para>
/// 
/// Creating a Sick Flow
/// --------------------
/// <para>The flow::generator namespace contains several factory methods for creating a Stream object. Probably the most
/// common generator used is from(), which creates a Stream from an iterator range or a container.</para>
/// \code{.cpp}auto stream = from(my_vector); // a stream over the entire vector in the same order \endcode
/// <para>Since it's very common, the pipe operator is overloaded for container types as a shorthand for from(). So the following
/// statements create and process the same stream.</para>
/// \code{.cpp}from(my_vector) | each(process);    // process each vector element
/// my_vector | each(process);          // shorthand, the same operation as above   \endcode
/// <para>Other common stream generators are iota(), which counts up from a value, repeat(), which repeats a value or
/// cycle(), which cycles a container.</para>
/// 
/// Manipulating a Sick Flow
/// ------------------------
/// <para>Say you want to loop through a list of numbers. But you only want the even values. Then you want the squares of those
/// values for some reason. Oh, and you want at most 10 of those. How would you do that in normal C++? Probably something like</para>
/// \code{.cpp}int count = 0;
/// for (auto it = list.begin(), end = list.end(); it != end & count < 10; ++it) {
///     if (*it % 2 == 0) {
///         ++count;
///         process(*it * *it);
///     }
/// }\endcode
/// 
/// <para>Not bad, but it's not quickly clear what is going on. The same operation can be done as a sick flow instead:</para>
/// \code{.cpp}list | filter([](int i) { return i % 2 == 0; }) | limit(10) | map([](int i) { return i*i; }) | each(process);\endcode
/// 
/// <para>Reading the line aloud, it's obvious what is happening. Take the list, keep even values, limit it to 10 elements,
/// map the elements to their square, and then process each of those. Fun. This is just a trivial example, there many other
/// stream operations available to be used.</para>
/// 
/// <para>Stream operations are broken down into two main types: Intermediate and Terminal operations. Intermediate operations
/// transform a stream into another stream. We saw three examples above in <c>filter</c>, <c>limit</c> and <c>map</c>. Intermediate
/// operations are meaningless without some sort of Terminal operation, such as <c>each</c> or <c>count</c>. Terminal operations
/// do something with the final stream data, be it summing, counting, calling a function, finding the min, and so on.</para>
/// <para>Intermediate operations are all inside the flow::intermediate namespace.<br/>Terminal operations are all inside the
/// flow::terminal namespace.</para>
/// 
/// ### A Word on the flow namespace
/// <para>All of the functions in flow::generator, flow::intermediate and flow::terminal are aliased to also be in the flow namespace.
/// For your program, if you do <c>using namespace flow;</c> (if you want), you get access to all the core parts of the flow library.
/// If not, you can still just write <c>flow::map</c> instead of <c>flow::intermediate::map</c>.</para>
/// 
/// ### Documentation at a Glance
/// <para>The best way to view all available functions, use the [Namespace Members](namespacemembers_func.html) page. It lists
/// every important function and the namespace it sits in, indicating whether it is a generator, or an intermediate or terminal operation.</para>
///


/// \namespace flow
/// The entire flow library is contained in the flow namespace.
/// <para>The flow library provides lazy evaluated, functional style transformations on data, allowing
/// for complex operations to be written in a clean, easy to understand and maintainable way. This
/// functionality is provided by the Stream class, coupled with stream operators.
/// Two types of stream operators exist: intermediate and terminal operations.</para>
/// <para>Intermediate operations take a stream as input and produce a new stream. Most intermediate
/// operations are lazily evaluated -- the stream is not evaluated until a value is required -- however
/// some are eager and require the entire stream to evaluated up front before the operation can be applied.
/// Eager operations also require an additional <c>O(n)</c> space, where <c>n</c> is the size of the stream,
/// whereas lazy operations only require <c>O(1)</c> space. In the documentation, all intermediate
/// operations are lazy unless noted otherwise.</para>
/// <para>Terminal operations take a stream as input and produce a non-stream output. The exact output depends on the
/// operation, it could be a stream element, a combination of stream elements (such as a sum), or maybe a <c>bool</c>.
/// As with intermediate operations, terminal operations are lazily evaluated.
/// After a terminal operation is applied to a stream, the stream is invalided. Using the stream afterwards
/// results in undefined behavior.</para>
/// <para>These operations are useless without an actual Stream. A Stream object can be obtained using a generator --
/// a factory method that gives you a Stream. All generators are also lazily evaluated.</para>
/// \li flow::generator contains the stream generators.
/// \li flow::intermediate contains intermediate operations.
/// \li flow::terminal contains terminal operations.
/// <para>Note that the operations are split into separate namespaces for organizational purposes, but all operations
/// are aliased to be in the flow namespace as well. If you want to, <c>using namespace flow;</c> will give you access
/// to the entire flow library. Otherwise, you only need to write flow::map, not flow::intermediate::map.</para>
/// 
/// Operating on a Stream
/// ---------------------
/// <para>All intermediate and terminal operations can be applied to a stream using <c>operator|</c>.</para>
/// \code{.cpp}int val = intstream | max(); // apply the `max` terminal to `intstream`\endcode
/// <para>Since intermediate operations return a new stream, operations can be chained together in interesting ways.</para>
/// \code{.cpp}int sum_squares = intstream | map([](int i) { return i * i; }) | sum();\endcode
/// <para>You can also create new operations from existing ones and apply those to streams. The type of operation
/// you create is the same as the last operation you combine.</para>
/// \code{.cpp}auto square_sum = map([](int i) { return i * i; }) | sum();  // square and sum; a terminal operation
/// auto add2_evens = filter([](int i) { return i % 2 == 0; }) | map([](int i) { return i + 2; });  // keep only even values, add 2 to them; an intermediate operation
/// int val = intstream | add2_evens | square_sum;  // does exactly what you think it does \endcode
/// <para>Terminal operators also have a method <c>then()</c>, which takes a function that uses the value produced
/// and produces a new terminal which composes the operations. For example, this method is used internally by none(),
/// a terminal that returns <c>true</c> if none of the stream elements match a predicate. Logically, this is the same
/// as finding if any of the elements match the predicate, then negating the result -- this is exactly what is done.</para>
/// \code{.cpp}auto my_none = any(my_predicate).then(std::logical_not<bool>());\endcode
/// 
/// \todo Java uses stream&lt;T&gt; instead of the template being the stream source. This makes it easier to return streams
/// or pass streams around, or have method that return streams or whatever. Currently, a function like below is not generally possible.
/// \code{.cpp}auto get_stream(T& t) {
///     return some_property(t) ? cycle(t, 2) : from(t);
/// }\endcode
/// Perhaps this way is actually better. Embedding the template allows for better optimizations to occur, but it makes the
/// stream type convoluted. It literally always is "a stream of ints" regardless of how many operations are in the source.
/// The only way I can think of to allow stream&lt;T&gt; to exist would be through the use of an abstract base source class,
/// and each source has a pointer to the source before it in the pipeline. This involves heavy use of virtual methods -
/// essentially every function call would need to be virtual. It would also allow for recursively defined streams though.
///


/// \namespace flow::generator
/// Factory methods to create stream objects, all of which are also aliased in the flow namespace.
/// <para>The functions in the flow::generator namespace all produce Stream objects.</para>
/// <para>Also defines <c>operator|</c> for container types to be a shorthand for from().
/// A container is defined to be any class with a <c>const_iterator</c> inner class,
/// and methods <c>begin()</c> and <c>end()</c>.</para>
/// \todo parallel_*() - create a parallel version of other generators?
/// 

/// \namespace flow::terminal
/// Terminal operations, all of which are also aliased in the flow namespace.
/// <para>The functions in the flow::terminal namespace all produce a terminal operation. The terminal
/// operation does not operate on a stream until the pipe <c>operator|</c> has been applied, after which
/// the terminal's return value is calculated.</para>
/// <para>Some terminal operations (such as min()) return an \ref optional object when the stream is empty.
/// This practice was chosen over throwing an exception, though there is no clear better way. In the end,
/// flow uses the optional class for the following reasons:</para>
/// <ul>
///     <li>In the exceptional case, a boolean check is much faster than an exception.</li>
///     <li>In many cases, you will know for sure that the optional returned contains a value and the boolean check
///         can be skipped anyways. Consider that many of the STL algorithms return iterators which are commonly used without
///         checking them for validity.</li>
///     <li>In other cases, when you don't know for sure if a value would exist, a boolean check only carries a very slight overhead.</li>
///     <li>It is less code on the user end which is always nice.</li>
/// </ul>
/// <para>Some convenience methods are available to Terminal operations:</para>
/// \code{.cpp}Terminal<F> then(F f);      // a terminal which applies f to the result of this terminal
/// Terminal<F> value();        // a terminal which directly accesses the optional's contained value, undefined if the optional has no value
/// Terminal<F> value_or(U&&);  // a terminal which directly calls optional::value_or \endcode
/// <para>Examples of these operations are available in \ref terminal.cpp.</para>
/// \todo parallel_*() - chunking parallelization of terminal operations
/// \todo parallel pipelining of stream operations?
/// \todo equals - check if two streams are equal
/// \todo find - filter(equal to) | first(); optional parameter to return if filtered stream is empty
/// \todo is_sorted - check if a stream is sorted by a comparator
/// \todo overload comparison operators between streams?
/// \todo to_group - convert to a std::map<T::property, std::vector<T>>
/// 

/// \namespace flow::intermediate
/// Intermediate operations, all of which are also aliased in the flow namespace.
/// <para>The functions in the flow::intermediate namespace all produce an intermediate operation. The
/// intermediate operation does not operate on a stream until the pipe <c>operator|</c> has been applied,
/// including eager operations. Only after being applied to a stream is the new stream created.</para>
/// \todo group the stream, [1,2,3,4,5] with group<2> -> [(1,2), (3,4)]
/// \todo moving window into the stream, [1,2,3] with window<2> -> [(1,2), (2,3)]
/// \todo adjacent_diff - from &lt;numeric&gt;
/// \todo partial_sum - from &lt;numeric&gt;
/// \todo inner_product - from &lt;numeric&gt;
/// \todo overload arithmetic operators as map operations?
/// \todo shuffle - would have to be eager, take rng as parameter
/// 

/// \namespace flow::source
/// Stream sources, internal to the flow library.
/// <para>Classes in the flow::source namespace provide the functionality for all of the generators and intermediate
/// operations. These are internal to the flow library, and are not aliased in the flow namespace.</para>
/// 

/// \namespace std
/// Overload <c>operator&lt;&lt;</c> for <c>std::tuple</c> and <c>std::pair</c>.
/// <para>Defines <c>operator&lt;&lt;</c> for <c>std::tuple</c> and <c>std::pair</c>. This definition is required by dump() for a stream
/// containing these types, such as a stream that uses the default zip() operation. For example,</para>
/// \code{.cpp}intstream | zip(more_ints) | dump(); // requires std::operator<< for tuples \endcode
/// <para>The <c>std</c> namespace can be removed by defining <c>\#define FLOW_PRINTTUPLE_NO_STD</c> before including <c>flow.h</c>.</para>
/// \code{.cpp}// remove std::operator<< for tuples and pairs
/// #define FLOW_PRINTTUPLE_NO_STD
/// #include <flow.h> \endcode
/// <para>This will cause statements like the above to be a compile error unless the operator is defined elsewhere inside of the <c>std</c>
/// namespace. If <c>FLOW_PRINTTUPLE_NO_STD</c> is defined, then <c>operator&lt;&lt;</c> is defined inside of the flow namespace instead.</para>
/// 
