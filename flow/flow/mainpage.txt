
/// \mainpage
/// Sick Flow, Bro
/// ==============
/// <para>Inspired by Java 8 [Streams](http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html),
/// flow is a C++14 library that provides lazy evaluation and functional transformations on data. It's like Haskell for C++.
/// The library provides many common data transformations, such as map, filter and fold, as well as other commonly used
/// operations like computing the sum, min and max or simply counting the number or elements. And all of it is packaged
/// in a nice, easy to read and understand syntax. To use, simply <c>\#include &lt;flow.h&gt;</c> in your C++14 program.
/// With fully optimized code (<c>-O3</c> or <c>/O2</c>), flow offers minimal performance penalties compared to
/// standard code, so there's no reason not to love.</para>
/// 
/// What is a Sick Flow?
/// --------------------
/// <para>A flow is usually called a stream. But if I called the library "Stream" I couldn't say "sick flow" all the time.
/// I'll use flow and stream interchangeably, just know that a stream is a source of data, data that you would want to
/// do things with.</para>
/// 
/// Creating a Sick Flow
/// --------------------
/// <para>The flow::generator namespace contains several factory methods for creating a Stream object. Probably the most
/// common generator used is from(), which creates a Stream from an iterator range or a container.</para>
/// <code>auto stream = from(my_vector); // a stream over the entire vector in the same order</code>
/// <para>Other common stream generators are iota(), which counts up from a value, repeat(), which repeats a value or
/// cycle(), which cycles a container.</para>
/// 
/// Manipulating a Sick Flow
/// ------------------------
/// <para>Say you want to loop through a list of numbers. But you only want the even values. Then you want the squares of those
/// values for some reason. Oh, and you want at most 10 of those. How would you do that in normal C++? Probably something like</para>
/// \code{.cpp}int count = 0;
/// for (auto it = list.begin(), end = list.end(); it != end & count < 10; ++it) {
///     if (*it % 2 == 0) {
///         ++count;
///         process(*it * *it);
///     }
/// }\endcode
/// 
/// <para>Not bad, but it's not quickly clear what is going on. The same operation can be done as a sick flow instead:</para>
/// \code{.cpp}list | filter([](int i) { return i % 2 == 0; }) | limit(10) | map([](int i) { return i*i; }) | each(process);\endcode
/// 
/// <para>Reading the line aloud, it's obvious what is happening. Take the list, keep even values, limit it to 10 elements,
/// map the elements to their square, and then process each of those. Fun. This is just a trivial example, there many other
/// stream operations available to be used.</para>
/// 
/// <para>Stream operations are broken down into two main types: Intermediate and Terminal operations. Intermediate operations
/// transform a stream into another stream. We saw three examples above in <c>filter</c>, <c>limit</c> and <c>map</c>. Intermediate
/// operations are meaningless without some sort of Terminal operation, such as <c>each</c> or <c>count</c>. Terminal operations
/// do something with the final stream data, be it summing, counting, calling a function, finding the min, and so on.</para>
/// <para>Intermediate operations are all inside the flow::intermediate namespace.<br/>Terminal operations are all inside the
/// flow::terminal namespace.</para>
/// 
/// ### A Word on the flow namespace
/// <para>All of the functions in flow::generator, flow::intermediate and flow::terminal are aliased to also be in the flow namespace.
/// For your program, if you do <c>using namespace flow;</c> (if you want), you get access to all the core parts of the flow library.
/// If not, you can still just write <c>flow::map</c> instead of <c>flow::intermediate::map</c>.</para>
/// 
/// ### Documentation at a Glance
/// <para>The best way to view all available functions, use the [Namespace Members](namespacemembers_func.html) page. It lists
/// every important function and the namespace it sits in, indicating whether it is a generator, or an intermediate or terminal operation.</para>


/// \namespace flow
/// The entire flow library is contained in the flow namespace.
/// <para>The flow library provides lazy evaluated, functional style transformations on data, allowing
/// for complex operations to be written in a clean, easy to understand and maintainable way. This
/// functionality is provided by the Stream class, coupled with stream operators.
/// Two types of stream operators exist: intermediate and terminal operations.</para>
/// <para>Intermediate operations take a stream as input and produce a new stream. Most intermediate
/// operations are lazily evaluated -- the stream is not evaluated until a value is required -- however
/// some are eager and require the entire stream to evaluated up front before the operation can be applied.
/// Eager operations also require an additional <c>O(n)</c> space, where <c>n</c> is the size of the stream,
/// whereas lazy operations only require <c>O(1)</c> space. In the documentation, all intermediate
/// operations are lazy unless noted otherwise.</para>
/// <para>Terminal operations take a stream as input and produce a non-stream output. The exact output depends on the
/// operation, it could be a stream element, a combination of stream elements (such as a sum), or maybe a <c>bool</c>.
/// As with intermediate operations, terminal operations are lazily evaluated.
/// After a terminal operation is applied to a stream, the stream is invalided. Using the stream afterwards
/// results in undefined behavior.</para>
/// <para>These operations are useless without an actual Stream. A Stream object can be obtained using a generator --
/// a factory method that gives you a Stream. All generators are also lazily evaluated.</para>
/// \li flow::generator contains the stream generators.
/// \li flow::intermediate contains intermediate operations.
/// \li flow::terminal contains terminal operations.
/// <para>Note that the operations are split into separate namespaces for organizational purposes, but all operations
/// are aliased to be in the flow namespace as well. If you want to, <c>using namespace flow;</c> will give you access
/// to the entire flow library. Otherwise, you only need to write flow::map, not flow::intermediate::map.</para>
/// 
/// Operating on a Stream
/// ---------------------
/// <para>All intermediate and terminal operations can be applied to a stream using <c>operator|</c>.</para>
/// \code{.cpp}int val = intstream | max(); // apply the `max` terminal to `intstream`\endcode
/// <para>Since intermediate operations return a new stream, operations can be chained together in interesting ways.</para>
/// \code{.cpp}int sum_squares = intstream | map([](int i) { return i * i; }) | sum();\endcode
/// <para>You can also create new operations from existing ones and apply those to streams. The type of operation
/// you create is the same as the last operation you combine.</para>
/// \code{.cpp}auto square_sum = map([](int i) { return i * i; }) | sum();  // square and sum; a terminal operation
/// auto add2_evens = filter([](int i) { return i % 2 == 0; }) | map([](int i) { return i + 2; });  // keep only even values, add 2 to them; an intermediate operation
/// int val = intstream | add2_evens | square_sum;  // does exactly what you think it does \endcode
/// <para>Terminal operators also have a method <c>then()</c>, which takes a function that uses the value produced
/// and produces a new terminal which composes the operations. For example, this method is used internally by none(),
/// a terminal that returns <c>true</c> if none of the stream elements match a predicate. Logically, this is the same
/// as finding if any of the elements match the predicate, then negating the result -- this is exactly what is done.</para>
/// \code{.cpp}auto my_none = any(my_predicate).then(std::logical_not<bool>());\endcode
/// 


/// \namespace flow::generator
/// Stream factory methods, all of which are also aliased in the flow namespace.
/// <para>The functions in the flow::generator namespace all produce Stream objects.</para>
/// <para>Also defines <c>operator|</c> for container types to be a shorthand for from().
/// A container is defined to be any class with a <c>const_iterator</c> inner class,
/// and methods <c>begin()</c> and <c>end()</c>.</para>
/// \todo flow::generator::random - generate stream values from a random number generator
/// \todo flow::generator::parallel_* - create a parallel version of other generators?
/// 

/// \namespace flow::terminal
/// Terminal operations, all of which are also aliased in the flow namespace.
/// <para>The functions in the flow::terminal namespace all produce a terminal operation. The terminal
/// operation does not operate on a stream until the pipe <c>operator|</c> has been applied, after which
/// the terminal's return value is calculated.</para>
/// \todo flow::terminal::parallel_* - chunking parallelization of terminal operations
/// \todo parallel pipelining of stream operations?
/// 

/// \namespace flow::intermediate
/// Intermediate operations, all of which are also aliased in the flow namespace.
/// <para>The functions in the flow::intermediate namespace all produce an intermediate operation. The
/// intermediate operation does not operate on a stream until the pipe <c>operator|</c> has been applied,
/// including eager operations. Only after being applied to a stream is the new stream created.</para>
/// \todo flow::intermediate::union - union two sorted/unique streams
/// \todo flow::intermediate::intersect - intersect two sorted/unique streams
/// \todo flow::intermediate::difference - compute the difference of two sorted/unique streams
/// \todo flow::intermediate::symmetric_difference - compute the symmetric difference of two sorted/unique streams
/// 

/// \namespace flow::source
/// Stream sources, internal to the flow library.
/// <para>Classes in the flow::source namespace provide the functionality for all of the generators and intermediate
/// operations. These are internal to the flow library, and are not aliased in the flow namespace.</para>
/// 

/// \namespace std
/// Overload <c>operator&lt;&lt;</c> for <c>std::tuple</c>.
/// <para>Defines <c>operator&lt;&lt;</c> for <c>std::tuple</c>. This definition is required by dump() for a tuple stream,
/// such as a stream that uses the default zip() operation. For example,</para>
/// \code{.cpp}intstream | zip(more_ints) | dump(); // requires std::operator<< for tuples \endcode
/// <para>This namespace and function can be removed by defining <c>\#define FLOW_PRINTTUPLE_NO_STD</c> before including <c>flow.h</c>.</para>
/// \code{.cpp}// remove std::operator<<
/// #define FLOW_PRINTTUPLE_NO_STD
/// #include <flow.h> \endcode
/// <para>This will cause statements like the above to be a compile error unless the operator is defined elsewhere.</para>
/// 
