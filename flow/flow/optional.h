
/**
 * \cond LICENSE
 * This is based on the future std::optional by Andrzej Krzemienski.
 * In the future (c++17?) this will be removed from flow in favor of std::optional.
 * 
 * Copyright (C) 2011 - 2012 Andrzej Krzemienski.
 * Use, modifcation, and distribution is subject to the Boost Software
 * License, Version 1.0.
 *
 * The idea and interface is based on Boost.Optional library
 * authored by Fernando Luis Cacciola Carballal
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * \endcond
 */

#ifndef FLOW_OPTIONAL_H
#define FLOW_OPTIONAL_H

namespace flow {

    namespace detail {

/// <summary>
/// Storage device for flow::optional.
/// </summary>
template <class T>
union optional_storage
{
public:
    /// <summary>
    /// Initializes a new empty instance of the optional_storage union.
    /// </summary>
    optional_storage() : _dummy() { }

    /// <summary>
    /// Initializes a new instance of the of the optional_storage union storing <paramref name="value"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    optional_storage(const T& value) : _value(value) { }

    /// <summary>
    /// Initializes a new instance of the of the optional_storage union storing <paramref name="value"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    optional_storage(T&& value) : _value(std::move(value)) { }

    /// <summary>
    /// Finalizes an instance of the optional_storage union.
    /// </summary>
    ~optional_storage() { }

    /// <summary>
    /// The dummy variable, the union value when there is no optional value.
    /// </summary>
    unsigned char _dummy;

    /// <summary>
    /// The actual value in the optional.
    /// </summary>
    T _value;
};
    }

/// <summary>
/// Manages an optionally contained value, one that may or may not be present.
/// <para>This optional stores a copy of the original value.</para>
/// <para>This class functions as a stripped down version of the soon to exist <c>std::optional</c>. Once
/// <c>std::optional</c> is released and implemented by major compilers, this class will be aliased to be <c>std::optional</c>
/// instead, and it will serve as a drop in replacement assuming the standard does not change.</para>
/// </summary>
template <class T>
class optional
{
public:
    /// <summary>
    /// Initializes a new instance of the optional class which contains no value.
    /// </summary>
    optional() : _init(false), _storage() { }

    /// <summary>
    /// Initializes a new instance of the optional class containing a copy of <paramref name="value"/>.
    /// </summary>
    /// <param name="value">The value to set.</param>
    optional(const T& value) : _init(true), _storage(value) { }

    /// <summary>
    /// Initializes a new instance of the optional class containing <paramref name="value"/>.
    /// </summary>
    /// <param name="value">The value to move into the contained value.</param>
    optional(T&& value) : _init(true), _storage(std::move(value)) { }

    /// <summary>
    /// Assigns the contained value to be <paramref name="value"/>.
    /// </summary>
    /// <param name="value">The value to set.</param>
    /// <returns><c>*this</c></returns>
    optional<T>& operator=(T& value) {
        _init = true;
        _storage._value = value;
        return *this;
    }

    /// <summary>
    /// Returns <c>true</c> if this object contains a value.
    /// </summary>
    /// <returns><c>true</c> if this object contains a value.</returns>
    operator bool() const {
        return _init;
    }

    /// <summary>
    /// Returns a pointer to the contained value, undefined if no there is no contained value.
    /// </summary>
    /// <returns>A pointer to the contained value.</returns>
    T* operator->() {
        return &_storage._value;
    }

    /// <summary>
    /// Returns a pointer to the contained value, undefined if there is no contained value.
    /// </summary>
    /// <returns>A pointer to the contained value.</returns>
    const T* operator->() const {
        return &_storage._value;
    }

    /// <summary>
    /// Returns a reference to the contained value, undefined if there is no contained value.
    /// </summary>
    /// <returns>A reference to the contained value.</returns>
    T& operator*() {
        return _storage._value;
    }

    /// <summary>
    /// Returns a reference to the contained value, undefined if there is no contained value.
    /// </summary>
    /// <returns>A reference to the contained value.</returns>
   const T& operator*() const {
        return _storage._value;
    }

   /// <summary>
   /// Returns a reference to the contained value.
   /// </summary>
   /// <returns>A reference to the contained value.</returns>
    /// <exception cref="std::logic_error">Thrown when there is no contained value.</exception>
   T& value() {
       if (*this) {
           return **this;
       }
       throw std::logic_error("bad optional access");
   }

   /// <summary>
   /// Returns a reference to the contained value.
   /// </summary>
   /// <returns>A reference to the contained value.</returns>
   /// <exception cref="std::logic_error">Thrown when there is no contained value.</exception>
   const T& value() const {
       if (*this) {
           return **this;
       }
       throw std::logic_error("bad optional access");
   }

   /// <summary>
   /// Returns a reference to the contained value if it exists, otherwise returns <paramref name="default_value"/>.
   /// </summary>
   /// <returns>A reference to the contained value if it exists, <paramref name="default_value"/> otherwise.</returns>
   T& value_or(T& default_value) {
       if (*this) {
           return **this;
       }
       return default_value;
   }

   /// <summary>
   /// Returns a reference to the contained value if it exists, otherwise returns <paramref name="default_value"/>.
   /// </summary>
   /// <returns>A reference to the contained value if it exists, <paramref name="default_value"/> otherwise.</returns>
   const T& value_or(const T& default_value) const {
       if (*this) {
           return **this;
       }
       return default_value;
   }

private:
    bool _init;                                 // true when there is actually a value
    flow::detail::optional_storage<T> _storage; // the value, or lack there of
};

/// <summary>
/// Manages an optionally contained reference, one that may or may not be present.
/// <para>This class functions as a stripped down version of the soon to exist <c>std::optional</c>. Once
/// <c>std::optional</c> is released and implemented by major compilers, this class will be aliased to be <c>std::optional</c>
/// instead, and it will serve as a drop in replacement assuming the standard does not change.</para>
/// </summary>
template <class T>
class optional<T&>
{
public:
    /// <summary>
    /// Initializes a new instance of the optional class which contains no value.
    /// </summary>
    optional() : _ref(nullptr) { }

    /// <summary>
    /// Initializes a new instance of the optional class containing <paramref name="value"/>.
    /// </summary>
    /// <param name="value">The value to set.</param>
    optional(T& value) : _ref(&value) { }

    /// <summary>
    /// Assigns the contained value to be <paramref name="value"/>.
    /// <para>This changes which value is referenced. The original contained value, if any, is not altered by this operation.</para>
    /// </summary>
    /// <param name="value">The value to set.</param>
    /// <returns><c>*this</c></returns>
    optional<T&>& operator=(T& value) {
        _ref = &value;
        return *this;
    }

    /// <summary>
    /// Returns <c>true</c> if this object contains a value.
    /// </summary>
    /// <returns><c>true</c> if this object contains a value.</returns>
    operator bool() const {
        return _ref != nullptr;
    }

    /// <summary>
    /// Returns a pointer to the contained value, undefined if there is no contained value.
    /// </summary>
    /// <returns>A pointer to the contained value.</returns>
    T* operator->() {
        return _ref;
    }

    /// <summary>
    /// Returns a pointer to the contained value, undefined if there is no contained value.
    /// </summary>
    /// <returns>A pointer to the contained value.</returns>
    const T* operator->() const {
        return _ref;
    }

    /// <summary>
    /// Returns a reference to the contained value, undefined if there is no contained value.
    /// </summary>
    /// <returns>A reference to the contained value.</returns>
    T& operator*() {
        return *_ref;
    }

    /// <summary>
    /// Returns a reference to the contained value, undefined if there is no contained value.
    /// </summary>
    /// <returns>A reference to the contained value.</returns>
    const T& operator*() const {
        return *_ref;
    }

    /// <summary>
    /// Returns a reference to the contained value.
    /// </summary>
    /// <returns>A reference to the contained value.</returns>
    /// <exception cref="std::logic_error">Thrown when there is no contained value.</exception>
    T& value() {
        if (*this) {
            return **this;
        }
        throw std::logic_error("bad optional access");
    }

    /// <summary>
    /// Returns a reference to the contained value.
    /// </summary>
    /// <returns>A reference to the contained value.</returns>
    /// <exception cref="std::logic_error">Thrown when there is no contained value.</exception>
    const T& value() const {
        if (*this) {
            return **this;
        }
        throw std::logic_error("bad optional access");
    }

    /// <summary>
    /// Returns a reference to the contained value if it exists, otherwise returns <paramref name="default_value"/>.
    /// </summary>
    /// <returns>A reference to the contained value if it exists, <paramref name="default_value"/> otherwise.</returns>
    T& value_or(T& default_value) {
        if (*this) {
            return **this;
        }
        return default_value;
    }

    /// <summary>
    /// Returns a reference to the contained value if it exists, otherwise returns <paramref name="default_value"/>.
    /// </summary>
    /// <returns>A reference to the contained value if it exists, <paramref name="default_value"/> otherwise.</returns>
    const T& value_or(const T& default_value) const {
        if (*this) {
            return **this;
        }
        return default_value;
    }

private:
    T* _ref;    // the value, nullptr when no value is contained
};
}
#endif
