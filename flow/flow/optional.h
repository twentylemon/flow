
/**
 * \cond LICENSE
 * This is based on the future std::optional by Andrzej Krzemienski.
 * In the future (c++17?) this will be removed from flow in favor of std::optional.
 * 
 * Copyright (C) 2011 - 2012 Andrzej Krzemienski.
 * Use, modifcation, and distribution is subject to the Boost Software
 * License, Version 1.0.
 *
 * The idea and interface is based on Boost.Optional library
 * authored by Fernando Luis Cacciola Carballal
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * \endcond
 */

#ifndef FLOW_OPTIONAL_H
#define FLOW_OPTIONAL_H

namespace flow {

    namespace detail {

template <class T>
union optional_storage
{
public:
    optional_storage() : _dummy() {};

    optional_storage(const T& value) : _value(value) { }

    ~optional_storage() {}

    unsigned char _dummy;
    T _value;
};
    }

template <class T>
class optional
{
public:
    optional() : _init(false), _storage() { }

    optional(const T& value) : _init(true), _storage(value) { }

    optional<T>& operator=(T& value) {
        _init = true;
        _storage._value = value;
        return *this;
    }

    operator bool() const {
        return _init;
    }

    T* operator->() {
        return &_storage._value;
    }

    const T* operator->() const {
        return &_storage._value;
    }

    T& operator*() {
        return _storage._value;
    }

   const T& operator*() const {
        return _storage._value;
    }

   T& value() {
       if (*this) {
           return **this;
       }
       throw std::logic_error("bad optional access");
   }

   const T& value() const {
       if (*this) {
           return **this;
       }
       throw std::logic_error("bad optional access");
   }

   T& value_or(T& default_value) {
       if (*this) {
           return **this;
       }
       return default_value;
   }

   const T& value_or(const T& default_value) const {
       if (*this) {
           return **this;
       }
       return default_value;
   }

private:
    bool _init;
    flow::detail::optional_storage<T> _storage;
};

template <class T>
class optional<T&>
{
public:
    optional() : _ref(nullptr) { }

    optional(T& v) : _ref(&v) { }

    optional<T&>& operator=(T& value) {
        _ref = &value;
        return *this;
    }

    operator bool() const {
        return _ref != nullptr;
    }

    T* operator->() {
        return _ref;
    }

    const T* operator->() const {
        return _ref;
    }

    T& operator*() {
        return *_ref;
    }

    const T& operator*() const {
        return *_ref;
    }

    T& value() {
        if (*this) {
            return **this;
        }
        throw std::logic_error("bad optional access");
    }

    const T& value() const {
        if (*this) {
            return **this;
        }
        throw std::logic_error("bad optional access");
    }

    T& value_or(T& default_value) {
        if (*this) {
            return **this;
        }
        return default_value;
    }

    const T& value_or(const T& default_value) const {
        if (*this) {
            return **this;
        }
        return default_value;
    }

private:
    T* _ref;
};
}
#endif
