{"name":"Flow","tagline":"C++ lazy evaluated stream processing","body":"\r\nsick flow, bro\r\n==============\r\n\r\nInspired by Java 8 [Streams](http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html),\r\nflow is a C++14 library that provides lazy evaluation and functional transformations on data. It's like Haskell for C++.\r\nThe library provides many common data transformations, such as map, filter and fold, as well as other commonly used\r\noperations like computing the sum, min and max or simply counting the number or elements. And all of it is packaged\r\nin a nice, easy to read and understand syntax. To use, simply `#include <flow.h>` in your C++14 program. With fully\r\noptimized code (`-O3` or `/O2`), flow offers minimal performance penalties, so there's no reason not to love.\r\n\r\n * [Documentation](http://twentylemon.github.io/flow/doxy/index.html)\r\n\r\n\r\nWhat is a Sick Flow?\r\n--------------------\r\nA flow is usually called a stream. But if I called the library \"Stream\" I couldn't say \"sick flow\" all the time.\r\nI'll use flow and stream interchangeably, just know that a stream is a source of data, data that would want to\r\ndo things with.\r\n\r\nCreating a Sick Flow\r\n--------------------\r\nThe `flow::generator` namespace contains several factory methods for creating a Stream object. Probably the most\r\ncommon generator used is `from()`, which creates a Stream from an iterator range or a container.\r\n\r\n```C++\r\nauto stream = from(my_vector); // a stream over the entire vector in the same order\r\n```\r\n\r\nSince it's very common, the pipe operator is overloaded for container types as a shorthand for from(). So the following\r\nstatements create and process the same stream.\r\n\r\n```C++\r\nfrom(my_vector) | each(process);    // process each vector element\r\nmy_vector | each(process);          // shorthand, the same operation as above\r\n```\r\n\r\nOther common stream generators are `iota()`, which counts up from a value, and `repeat()`, which repeats a value.\r\nSeveral others are included in the flow::generator namespace.\r\n\r\nManipulating a Sick Flow\r\n------------------------\r\nSay you want to loop through a list of numbers. But you only want the even values. Then you want the squares of those\r\nvalues for some reason. Oh, and you want at most 10 of those. How would you do that in normal C++? Probably something like\r\n\r\n```C++\r\nint count = 0;\r\nfor (auto it = list.begin(), end = list.end(); it != end & count < 10; ++it) {\r\n    if (*it % 2 == 0) {\r\n        ++count;\r\n        process(*it * *it);\r\n    }\r\n}\r\n```\r\n\r\nNot bad, but it's not quickly clear what is going on. The same operation can be done as a sick flow instead:\r\n\r\n```C++\r\nlist\r\n    | filter([](int i) { return i % 2 == 0; })\r\n    | map([](int i) { return i*i; })\r\n    | limit(10)\r\n    | each(process);\r\n```\r\n\r\nReading the flow aloud, it's obvious what is happening. Take the list, keep even values, map the elements to their square,\r\nlimit it to 10 elements, and then process each of those. Fun. This is just a trivial example, there many other\r\nstream operations available to be used.\r\n\r\nStream operations are broken down into two main types: Intermediate and Terminal operations. Intermediate operations\r\ntransform a stream into another stream. We saw three examples above in `filter`, `limit` and `map`. Intermediate\r\noperations are meaningless without some sort of Terminal operation, such as `each` or `count`. Terminal operations\r\ndo something with the final stream data, be it summing, counting, calling a function, finding the min, and so on.\r\n\r\nIntermediate operations are all inside the flow::intermediate namespace.\r\n\r\nTerminal operations are all inside the flow::terminal namespace.\r\n\r\n### A Word on the flow namespace\r\nAll of the functions in `flow::generator`, `flow::intermediate` and `flow::terminal` are aliased to also be in the `flow` namespace.\r\nFor your program, if you do `using namespace flow;` (if you want), you get access to all the core parts of the flow library.\r\nIf not, you can still just write `flow::map` instead of `flow::intermediate::map`.\r\n\r\n### Documentation at a Glance\r\nThe best way to view all available functions, use the <a href=\"https://twentylemon.github.io/flow/doxy/namespacemembers_func.html\">Namespace Members</a> page. It lists\r\nevery important function and the namespace it sits in, indicating whether it is a generator, or an intermediate or terminal operation.\r\n\r\nExamples\r\n--------\r\n### Basic Iteration\r\n```C++\r\nmy_vector | each([](auto& ele) {\r\n    fancy_things(ele);\r\n    more_fancy_things(ele);\r\n});\r\n```\r\n\r\n### Display Streams\r\n```C++\r\npeople | map(&Person::name) | dump();       // display to std::cout\r\n// or, if Person::operator<< exists\r\npeople | dump(why_not_into_a_file, \"\\n\");   // with a new line between each one\r\n```\r\n\r\n### Basic Statistics\r\n```C++\r\nauto male_age_stats = people\r\n    | filter([](Person& p) { return p.sex() == Person::Sex::Male; })\r\n    | map(&Person::age)\r\n    | stats();  // gets mean, standard deviation; can optionally get min/max, median/mode\r\n\r\n// get frequency of each age in the group\r\nauto age_distribution = people | map(&Person::age) | to_map();  // or to_unordered_map()\r\n```\r\n\r\n### Infinite Streams\r\n```C++\r\nusing boost::multiprecision::cpp_int;\r\nauto nth_fibonacci = iterate(std::plus<cpp_int>(), cpp_int(0), cpp_int(1)) | nth(1000); // some huge number\r\n\r\niota(1) | filter([](int i) { return i % 2 == 0; }); // a stream containing all even values\r\niota(2, 2); // or, this is the same, start from 2 counting up by 2\r\n\r\nrandom_engine(std::mt19937());  // infinite stream of randomly generated values\r\nrandom_ints(0, 10);             // random ints in the range [0,10]\r\ngenerate(std::rand);            // even more randoms!\r\n```\r\n\r\n### Assign IDs to Objects\r\n```C++\r\nwidgets | zip(iota(1), [](Widget& w, int id) { w.set_id(id); return id; }) | execute();\r\n```\r\n\r\n### Sorted Stream Operations\r\n```C++\r\nstd::vector<int> x = { 1, 2, 3, 4 };\r\nstd::vector<int> y = { 1, 3, 5, 7 };\r\n\r\nauto xy_union = x | set_union(y) | to_vector();             // { 1, 2, 3, 4, 5, 7 }\r\nauto xy_intersection = x | set_intersect(y) | to_vector();  // { 1, 3 }\r\nauto xy_difference = x | set_diff(y) | to_vector();         // { 2, 4 }\r\nauto xy_sym_diff = x | set_sym_diff(y) | to_vector();       // { 2, 4, 5, 7 }\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}